

Prompt for target technology
CONFIG_SYN_INFERRED
  Selects the target technology for memory and pads. 
  The following are available:

  - Inferred: Generic FPGA or ASIC targets if your synthesis tool
    is capable of inferring RAMs and pads automatically.

  - Actel ProAsic/P/3 and Axellerator FPGAs
  - Aeroflex UT25CRH Rad-Hard 0.25 um CMOS 
  - Altera: Most Altera FPGA families
  - Altera-Stratix: Altera Stratix FPGA family
  - Altera-StratixII: Altera Stratix-II FPGA family
  - ATC18: Atmel-Nantes 0.18 um rad-hard CMOS
  - IHP25: IHP 0.25 um CMOS
  - IHP25RH: IHP Rad-Hard 0.25 um CMOS
  - Lattice : EC/ECP/XP FPGAs
  - Quicklogic : Eclipse/E/II FPGAs
  - UMC-0.18 : UMC 0.18 um CMOS with Virtual Silicon libraries
  - Xilinx-Spartan/2/3: Xilinx Spartan/2/3 libraries
  - Xilinx-Spartan3E: Xilinx Spartan3E libraries
  - Xilinx-Virtex/E: Xilinx Virtex/E libraries
  - Xilinx-Virtex2/4/5: Xilinx Virtex2/4/5 libraries


Ram library
CONFIG_MEM_VIRAGE
  Select RAM generators for ASIC targets. 

Infer ram
CONFIG_SYN_INFER_RAM
  Say Y here if you want the synthesis tool to infer your
  RAM automatically. Say N to directly instantiate technology-
  specific RAM cells for the selected target technology package.

Infer pads
CONFIG_SYN_INFER_PADS
  Say Y here if you want the synthesis tool to infer pads.
  Say N to directly instantiate technology-specific pads from
  the selected target technology package.

No async reset
CONFIG_SYN_NO_ASYNC
  Say Y here if you disable asynchronous reset in some of the IP cores.
  Might be necessary if the target library does not have cells with
  asynchronous set/reset.

Scan support
CONFIG_SYN_SCAN
  Say Y here to enable scan support in some cores. This will enable
  the scan support generics where available and add logic to make
  the design testable using full-scan.

Use Virtex CLKDLL for clock synchronisation
CONFIG_CLK_INFERRED
  Certain target technologies include clock generators to scale or
  phase-adjust the system and SDRAM clocks. This is currently supported
  for Xilinx, Altera and Proasic3 FPGAs. Depending on technology, you
  can select to use the Xilinx CKLDLL macro (Virtex, VirtexE, Spartan1/2),
  the Xilinx DCM (Virtex-2, Spartan3, Virtex-4), the Altera ALTDLL
  (Stratix, Cyclone), or the Proasic3 PLL. Choose the 'inferred' 
  option to skip a clock generator.

Clock multiplier
CONFIG_CLK_MUL
  When using the Xilinx DCM or Altera ALTPLL, the system clock can
  be multiplied with a factor of 2 - 32, and divided by a factor of
  1 - 32. This makes it possible to generate almost any desired 
  processor frequency. When using the Xilinx CLKDLL generator,
  the resulting frequency scale factor (mul/div) must be one of
  1/2, 1 or 2. On Proasic3, the factor can be 1 - 128.

  WARNING: The resulting clock must be within the limits specified
  by the target FPGA family.

Clock divider
CONFIG_CLK_DIV
  When using the Xilinx DCM or Altera ALTPLL, the system clock can
  be multiplied with a factor of 2 - 32, and divided by a factor of
  1 - 32. This makes it possible to generate almost any desired 
  processor frequency. When using the Xilinx CLKDLL generator,
  the resulting frequency scale factor (mul/div) must be one of
  1/2, 1 or 2. On Proasic3, the factor can be 1 - 128.

  WARNING: The resulting clock must be within the limits specified
  by the target FPGA family.

Output clock divider
CONFIG_OCLK_DIV
  When using the Proasic3 PLL, the system clock is generated by three
  parameters: input clock multiplication, input clock division and
  output clock division. Only certain values of these parameters
  are allowed, but unfortunately this is not documented by Actel.
  To find the correct values, run the Libero Smartgen tool and
  insert you desired input and output clock frequencies in the
  Static PLL configurator. The mul/div factors can then be read
  out from tool.

System clock multiplier
CONFIG_CLKDLL_1_2
  The Xilinx CLKDLL can scale the input clock with a factor of 0.5, 1.0, 
  or 2.0. Useful when the target board has an oscillator with a too high 
  (or low) frequency for your design. The divided clock will be used as the
  main clock for the whole processor (except PCI and ethernet clocks).

System clock multiplier
CONFIG_DCM_2_3
  The Xilinx DCM and Altera ALTDLL can scale the input clock with a large
  range of factors. Useful when the target board has an oscillator with a 
  too high (or low) frequency for your design. The divided clock will
  be used as the main clock for the whole processor (except PCI and 
  ethernet clocks). NOTE: the resulting frequency must be at least
  24 MHz or the DCM and ALTDLL might not work.

Enable CLKDLL for PCI clock
CONFIG_PCI_CLKDLL
  Say Y here to re-synchronize the PCI clock using a 
  Virtex BUFGDLL macro. Will improve PCI clock-to-output 
  delays on the expense of input-setup requirements.

Use PCI clock system clock
CONFIG_PCI_SYSCLK
  Say Y here to the PCI clock to generate the system clock.
  The PCI clock can be scaled using the DCM or CLKDLL to 
  generate a suitable processor clock.

External SDRAM clock feedback
CONFIG_CLK_NOFB
  Say Y here to disable the external clock feedback to synchronize the
  SDRAM clock. This option is necessary if your board or design does not
  have an external clock feedback that is connected to the pllref input
  of the clock generator.
CoreMP7 with GRLIB bridge
CONFIG_CMP7GRLIB
  Say Y here to enable a CoreMP7 processor together with a GRLIB bridge.

Debug choice
CONFIG_CMP7GRLIB_DEBUG
  Select 0 for no debug and 2 for debug. Make sure to select the correct
  CoreMP7 netlist depending on this option. This value is propagated
  directly to the CoreMP7Bridge.

Synchronize nFIQ
CONFIG_CMP7GRLIB_SYNCFIQ
  Synchronized nFIQ. Set to 0 for no synchronization.
  This value is propagated directly to the CoreMP7Bridge.

Synchronize nIRQ
CONFIG_CMP7GRLIB_SYNCIRQ
  Synchronized nIRQ. Set to 0 for no synchronization.
  This value is propagated directly to the CoreMP7Bridge.CONFIG_AHB_DEFMST
  Sets the default AHB master (see AMBA 2.0 specification for definition).
  Should not be set to a value larger than the number of AHB masters - 1.
  For highest processor performance, leave it at 0.

Default AHB master
CONFIG_AHB_RROBIN
  Say Y here to enable round-robin arbitration of the AHB bus. A N will
  select fixed priority, with the master with the highest bus index having
  the highest priority.

Support AHB split-transactions
CONFIG_AHB_SPLIT
  Say Y here to enable AHB split-transaction support in the AHB arbiter.
  Unless you actually have an AHB slave that can generate AHB split
  responses, say N and save some gates.

Default AHB master
CONFIG_AHB_IOADDR
  Selects the MSB adddress (HADDR[31:20]) of the AHB IO area, as defined 
  in the plug&play extentions of the AMBA bus. Should be kept to FFF 
  unless you really know what you are doing.

APB bridge address          
CONFIG_APB_HADDR
  Selects the MSB adddress (HADDR[31:20]) of the APB bridge. Should be
  kept at 800 for software compatibility. 

AHB monitor                 
CONFIG_AHB_MON
  Say Y to enable the AHB bus monitor. The monitor will check for
  illegal AHB transactions during simulation. It has no impact on
  synthesis.

Report AHB errors
CONFIG_AHB_MONERR
  Print out detected AHB violations on console.

Report AHB warnings
CONFIG_AHB_MONWAR
  Print out detected AHB warnings on console.


DSU enable
CONFIG_DSU_UART
  Say Y to enable the AHB uart (serial-to-AHB). This is the most
  commonly used debug communication link.

JTAG Enable
CONFIG_DSU_JTAG
  Say Y to enable the JTAG debug link (JTAG-to-AHB). Debugging is done 
  with GRMON through the boards JTAG chain at speed of 300 kbits/s. 
  Supported JTAG cables are Xilinx Parallel Cable III and IV.  

Ethernet DSU enable
CONFIG_DSU_ETH
  Say Y to enable the Ethernet Debug Communication Link (EDCL). The link
  provides a DSU gateway between ethernet and the AHB bus. Debugging is
  done at 10 or 100 Mbit/s, using the GRMON debug monitor. You must
  enable the GRETH Ethernet MAC for this option to become active.

Size of EDCL trace buffer
CONFIG_DSU_ETHSZ1
  Select the buffer size (in kbytes) for the EDCL. 1 or 2 kbyte is
  usually enough, while a larger buffer will increase the transfer rate.
  When operating at 100 Mbit, use a buffer size of at least 8 kbyte for
  maximum throughput.

MSB IP address
CONFIG_DSU_IPMSB
  Set the MSB 16 bits of the IP address of the EDCL.

LSB IP address
CONFIG_DSU_IPLSB
  Set the LSB 16 bits of the IP address of the EDCL.

MSB ethernet address
CONFIG_DSU_ETHMSB
  Set the MSB 24 bits of the ethernet address of the EDCL.

LSB ethernet address
CONFIG_DSU_ETHLSB
  Set the LSB 24 bits of the ethernet address of the EDCL.

Programmable MAC/IP address
CONFIG_DSU_ETH_PROG
  Say Y to make the LSB 4 bits of the EDCL MAC and IP address
  configurable using the ethi.edcladdr inputs.
Leon2 memory controller
CONFIG_MCTRL_LEON2
  Say Y here to enable the LEON2 memory controller. The controller
  can access PROM, I/O, SRAM and SDRAM. The bus width for PROM
  and SRAM is programmable to 8-, 16- or 32-bits.

8-bit memory support
CONFIG_MCTRL_8BIT
  If you say Y here, the PROM/SRAM memory controller will support
  8-bit mode, i.e. operate from 8-bit devices as if they were 32-bit.
  Say N to save a few hundred gates.

16-bit memory support
CONFIG_MCTRL_16BIT
  If you say Y here, the PROM/SRAM memory controller will support
  16-bit mode, i.e. operate from 16-bit devices as if they were 32-bit.
  Say N to save a few hundred gates.

Write strobe feedback
CONFIG_MCTRL_WFB
  If you say Y here, the PROM/SRAM write strobes (WRITEN, WEN) will
  be used to enable the data bus drivers during write cycles. This
  will guarantee that the data is still valid on the rising edge of
  the write strobe. If you say N, the write strobes and the data bus
  drivers will be clocked on the rising edge, potentially creating
  a hold time problem in external memory or I/O. However, in all
  practical cases, there is enough capacitance in the data bus lines
  to keep the value stable for a few (many?) nano-seconds after the
  buffers have been disabled, making it safe to say N and remove a 
  combinational path in the netlist that might be difficult to 
  analyze.

Write strobe feedback
CONFIG_MCTRL_5CS
  If you say Y here, the 5th (RAMSN[4]) SRAM chip select signal will
  be enabled. If you don't intend to use it, say N and save some gates.

SDRAM controller enable
CONFIG_MCTRL_SDRAM
  Say Y here to enabled the PC100/PC133 SDRAM controller. If you don't
  intend to use SDRAM, say N and save about 1 kgates.

SDRAM controller inverted clock
CONFIG_MCTRL_SDRAM_INVCLK
  If you say Y here, the SDRAM controller output signals will be delayed
  with 1/2 clock in respect to the SDRAM clock. This will allow the used
  of an SDRAM clock which in not strictly in phase with the internal 
  clock. This option will limit the SDRAM frequency to 40 - 50 MHz.

  On FPGA targets without SDRAM clock synchronizations through PLL/DLL, 
  say Y. On ASIC targets, say N and tell your foundry to balance the 
  SDRAM clock output.

SDRAM separate address buses
CONFIG_MCTRL_SDRAM_SEPBUS
  Say Y here if your SDRAM is connected through separate address
  and data buses (SA & SD). This is the case on the GR-CPCI-XC2V6000
  board, but not on the GR-PCI-XC2V3000 or Avnet XCV1500E boards.

64-bit data bus
CONFIG_MCTRL_SDRAM_BUS64
  Say Y here to enable 64-bit SDRAM data bus.

Page burst enable
CONFIG_MCTRL_PAGE
  Say Y here to enable SDRAM page burst operation. This will implement
  read operations using page bursts rather than 8-word bursts and save
  about 500 gates (100 LUTs). Note that not all SDRAM supports page 
  burst, so use this option with care.

Programmable page burst enable
CONFIG_MCTRL_PROGPAGE
  Say Y here to enable programmable SDRAM page burst operation. This
  will allow to dynamically enable/disable page burst by setting
  bit 17 in MCFG2.

SDRAM controller enable
CONFIG_SSCTRL
  Say Y here to enabled a 32-bit synchronous SRAM (SSRAM) controller.
  The controller is designed for piplined ZBT SSRAM.

CONFIG_SSCTRL_PROM16
  Say Y here to enabled a 16-bit PROM support. The PROM should be
  connected to D[31:16] of the data bus.

On-chip rom
CONFIG_AHBROM_ENABLE
  Say Y here to add a block on on-chip rom to the AHB bus. The ram
  provides 0-waitstates read access,  burst support, and 8-, 16- 
  and 32-bit data size. The rom will be syntheised into block rams
  on Xilinx and Altera FPGA devices, and into gates on ASIC 
  technologies. GRLIB includes a utility to automatically create
  the rom VHDL model (ahbrom.vhd) from an ELF file. Refer to the GRLIB
  documentation for details.

On-chip rom address
CONFIG_AHBROM_START
  Set the start address of AHB ROM (HADDR[31:20]). The ROM will occupy
  a 1 Mbyte slot at the selected address. Default is 000, corresponding
  to AHB address 0x00000000. When address 0x0 is selected, the rom area
  of any other memory controller is set to 0x10000000 to avoid conflicts.

Enable pipeline register for on-chip rom
CONFIG_AHBROM_PIPE
  Say Y here to add a data pipeline register to the on-chip rom.
  This should be done when the rom is implemenented in (ASIC) gates,
  or in logic cells on FPGAs. Do not use this option when the rom is
  implemented in block rams. If enabled, the rom will operate with 
  one waitstate.

On-chip ram
CONFIG_AHBRAM_ENABLE
  Say Y here to add a block on on-chip ram to the AHB bus. The ram
  provides 0-waitstates read access and 0/1 waitstates write access.
  All AHB burst types are supported, as well as 8-, 16- and 32-bit
  data size.

On-chip ram size
CONFIG_AHBRAM_SZ1
  Set the size of the on-chip AHB ram. The ram is infered/instantiated
  as four byte-wide ram slices to allow byte and half-word write
  accesses. It is therefore essential that the target package can
  infer byte-wide rams. This is currently supported on the generic,
  virtex, virtex2, proasic and axellerator targets.

On-chip ram address
CONFIG_AHBRAM_START
  Set the start address of AHB RAM (HADDR[31:20]). The RAM will occupy
  a 1 Mbyte slot at the selected address. Default is A00, corresponding
  to AHB address 0xA0000000.

Gaisler Ethernet MAC enable
CONFIG_GRETH_ENABLE
  Say Y here to enable the Gaisler Research Ethernet MAC . The MAC has 
  one AHB master interface to read and write packets to memory, and one
  APB slave interface for accessing the control registers. 

Gaisler Ethernet 1G MAC enable
CONFIG_GRETH_GIGA
  Say Y here to enable the Gaisler Research 1000 Mbit Ethernet MAC . 
  The 1G MAC is only available in the commercial version of GRLIB,
  so do NOT enable it if you are using the GPL version.

CONFIG_GRETH_FIFO4
  Set the depth of the receive and transmit FIFOs in the MAC core.
  The MAC core will perform AHB burst read/writes with half the
  size of the FIFO depth.


CAN interface enable
CONFIG_CAN_ENABLE
  Say Y here to enable the CAN interace from OpenCores. The core has one
  AHB slave interface for accessing the control registers. The CAN core
  ir register-compatible with the SAJ1000 core from Philips.

CAN register address
CONFIG_CANIO
  The control registers of the CAN core occupy 4 kbyte, and are 
  mapped in the AHB bus I/O area (0xFFF00000 - 0xFFFFF000). This setting
  defines at which address in the I/O area the registers appear (HADDR[19:8]).

CAN interrupt
CONFIG_CANIRQ
  Defines which interrupt number the CAN core will generate.

CAN loob-back testing
CONFIG_CANLOOP
  If you say Y here, the receiver and trasmitter of the CAN core will
  be connected together in a loop-back fashion. This will make it 
  possible to perform loop-back test, but not data will be sent
  or received from the outside. ONLY for testing!

CAN Synchronous reset
CONFIG_CAN_SYNCRST
  If you say Y here, the CAN core will be implemented with
  synchronous reset rather than asynchronous. This is needed
  when the target library does not implement registers with
  async reset. Unless you know what you are doing, say N.

CAN FT memories
CONFIG_CAN_FT
  If you say Y here, the CAN FIFOs will be implemented using
  SEU protected RAM blocks. Only applicable to the FT version
  of grlib.
UART1 enable
CONFIG_UART1_ENABLE
  Say Y here to enable UART1, or the console UART. This is needed to
  get any print-out from LEON3 systems regardless of operating system.

UART1 FIFO
CONFIG_UA1_FIFO1
  The UART has configurable transmitt and receive FIFO's, which can
  be set to 1 - 32 bytes. Use 1 for minimum area, or 8 - 32 for
  maximum throughput.


LEON3 interrupt controller
CONFIG_IRQ3_ENABLE
  Say Y here to enable the LEON3 interrupt controller. This is needed
  if you want to be able to receive interrupts. Operating systems like
  Linux, RTEMS and eCos needs this option to be enabled. If you intend
  to use the Bare-C run-time and not use interrupts, you could disable
  the interrupt controller and save about 500 gates.

LEON3 interrupt controller broadcast
CONFIG_IRQ3_BROADCAST_ENABLE
  If enabled the broadcast register is used to determine which
  interrupt should be sent to all cpus instead of just the first
  one that consumes it.

Secondary interrupts
CONFIG_IRQ3_SEC
  The interrupt controller handles 15 interrupts by default (1 - 15).
  These correspond to the 15 SPARC asyncronous traps (0x11 - 0x1F),
  and AMBA interrupts 1 - 15. This option will enable 16 additional
  (secondary) interrupts, corresponding to AMBA interrupts 16 - 31.
  The secondary interrupts will be multiplexed onto one of the first
  15 interrupts. The total number of handled interrupts can then
  be up to 30 (14 primary and 16 secondary).

Number of interrupts
CONFIG_IRQ3_NSEC
  Defines which of the first 15 interrupts should be used for the
  secondary (16 - 31) interrupts. Interrupt 15 should be avoided
  since it is not maskable by the processor.
Timer module enable
CONFIG_GPT_ENABLE
  Say Y here to enable the Modular Timer Unit. The timer unit consists
  of one common scaler and up to 7 independent timers. The timer unit
  is needed for Linux, RTEMS, eCos and the Bare-C run-times.

Timer module enable
CONFIG_GPT_NTIM
  Set the number of timers in the timer unit (1 - 7).

Scaler width
CONFIG_GPT_SW
  Set the width if the common pre-scaler (2 - 16 bits). The scaler
  is used to divide the system clock down to 1 MHz, so 8 bits should
  be sufficient for most implementations (allows clocks up to 256 MHz).

Timer width
CONFIG_GPT_TW
  Set the width if the timers (2 - 32 bits). 32 bits is recommended
  for the Bare-C run-time, lower values (e.g. 16 bits) can work with
  RTEMS and Linux.

Timer Interrupt
CONFIG_GPT_IRQ
  Set the interrupt number for the first timer. Remaining timers will
  have incrementing interrupts, unless the separate-interrupts option
  below is disabled.

Watchdog enable
CONFIG_GPT_WDOGEN
  Say Y here to enable the watchdog functionality in the timer unit.

Watchdog time-out value
CONFIG_GPT_WDOG
  This value will be loaded in the watchdog timer at reset.

GPIO port
CONFIG_GRGPIO_ENABLE
  Say Y here to enable a general purpose I/O port. The port can be
  configured from 1 - 32 bits, whith each port signal individually
  programmable as input or output. The port signals can also serve
  as interrupt inputs.

GPIO port witdth
CONFIG_GRGPIO_WIDTH
  Number of bits in the I/O port. Must be in the range of 1 - 32.

GPIO interrupt mask
CONFIG_GRGPIO_IMASK
  The I/O port interrupt mask defines which bits in the I/O port
  should be able to create an interrupt. 

UART debugging
CONFIG_DEBUG_UART
  During simulation, the output from the UARTs is printed on the
  simulator console. Since the ratio between the system clock and
  UART baud-rate is quite high, simulating UART output will be very
  slow. If you say Y here, the UARTs will print a character as soon
  as it is stored in the transmitter data register. The transmitter
  ready flag will be permanently set, speeding up simulation. However,
  the output on the UART tx line will be garbled.  Has not impact on
  synthesis, but will cause the LEON test bench to fail.

FPU register tracing
CONFIG_DEBUG_FPURF
  If you say Y here, all writes to the floating-point unit register file
  will be printed on the simulator console.

