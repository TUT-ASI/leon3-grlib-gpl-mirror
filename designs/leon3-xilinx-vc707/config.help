

Prompt for target technology
CONFIG_SYN_INFERRED
  Selects the target technology for memory and pads.
  The following are available:

  - Inferred: Generic FPGA or ASIC targets if your synthesis tool
    is capable of inferring RAMs and pads automatically.

  - Actel ProAsic/P/3, IGLOO/2, RTG4 and Axcelerator FPGAs
  - Aeroflex UT25CRH Rad-Hard 0.25 um CMOS
  - Altera: Most Altera FPGA families
  - Altera-CycloneIII: Altera Cyclone-III/IV FPGA family
  - Altera-Stratix: Altera Stratix FPGA family
  - Altera-StratixII: Altera Stratix/Cyclone-II FPGA families
  - Altera-StratixIII: Altera Stratix-III FPGA family
  - Altera-StratixIV: Altera Stratix-IV FPGA family
  - Altera-StratixV: Altera Stratix-V FPGA family
  - ATC18: Atmel-Nantes 0.18 um rad-hard CMOS
  - Lattice : EC/ECP/XP FPGAs
  - Quicklogic : Eclipse/E/II FPGAs
  - UMC-0.18 : UMC 0.18 um CMOS with Virtual Silicon libraries
  - Xilinx-Spartan/2/3/6: Xilinx Spartan/2/3/6 libraries
  - Xilinx-Spartan3E: Xilinx Spartan3E libraries
  - Xilinx-Virtex/E: Xilinx Virtex/E libraries
  - Xilinx-Virtex2/4/5/6/7: Xilinx Virtex2/4/5/6/7 libraries

  Note: Level of technology support depends on type of GRLIB
  distribution. A technology may be present in this list while the
  tech support files are missing from the GRLIB distribution.
  Actel support is only available in commercial and FT distributions.

  Additional target technologies are available that are not selectable
  via the xconfig tool.

Ram library
CONFIG_MEM_VIRAGE
  Select RAM generators for ASIC targets.

Transceiver type
CONFIG_TRANS_GTP0
  Select the transceiver type used in your FPGA

Infer ram
CONFIG_SYN_INFER_RAM
  Say Y here if you want the synthesis tool to infer your
  RAM automatically. Say N to directly instantiate technology-
  specific RAM cells for the selected target technology package.

Infer pads
CONFIG_SYN_INFER_PADS
  Say Y here if you want the synthesis tool to infer pads.
  Say N to directly instantiate technology-specific pads from
  the selected target technology package.

No async reset
CONFIG_SYN_NO_ASYNC
  Say Y here if you disable asynchronous reset in some of the IP cores.
  Might be necessary if the target library does not have cells with
  asynchronous set/reset.

Scan support
CONFIG_SYN_SCAN
  Say Y here to enable scan support in some cores. This will enable
  the scan support generics where available and add logic to make
  the design testable using full-scan.

Use Virtex CLKDLL for clock synchronisation
CONFIG_CLK_INFERRED
  Certain target technologies include clock generators to scale or
  phase-adjust the system and SDRAM clocks. This is currently supported
  for Xilinx, Altera and Proasic3 FPGAs. Depending on technology, you
  can select to use the Xilinx CKLDLL macro (Virtex, VirtexE, Spartan1/2),
  the Xilinx DCM (Virtex-2, Spartan3, Virtex-4), the Xilinx PLLE2 (Virtex-7,
  Kintex-7, Artix-4), the Altera ALTDLL (Stratix, Cyclone), or the 
  Proasic3 PLL. Choose the 'inferred' option to skip a clock generator.

Clock multiplier
CONFIG_CLK_MUL
  When using the Xilinx DCM, Xilinx PLLE2 or Altera ALTPLL, 
  the system clock can be multiplied with a factor of 2 - 32, 
  and divided by a factor of 1 - 32. This makes it possible to 
  generate almost any desired processor frequency. When using 
  the Xilinx CLKDLL generator, the resulting frequency scale f
  actor (mul/div) must be one of 1/2, 1 or 2. On Proasic3, 
  the factor can be 1 - 128. 
  
  WARNING: The resulting clock must be within the limits specified
  by the target FPGA family.

Clock divider
CONFIG_CLK_DIV
  When using the Xilinx DCM, Xilinx PLLE2 or Altera ALTPLL, 
  the system clock can be multiplied with a factor of 2 - 32, 
  and divided by a factor of 1 - 32. This makes it possible to 
  generate almost any desired processor frequency. When using 
  the Xilinx CLKDLL generator, the resulting frequency scale f
  actor (mul/div) must be one of 1/2, 1 or 2. On Proasic3, 
  the factor can be 1 - 128. 
  
  WARNING: The resulting clock must be within the limits specified
  by the target FPGA family.

Output clock divider
CONFIG_OCLK_DIV
  When using the Proasic3 PLL, the system clock is generated by three
  parameters: input clock multiplication, input clock division and
  output clock division. Only certain values of these parameters
  are allowed, but unfortunately this is not documented by Actel.
  To find the correct values, run the Libero Smartgen tool and
  insert you desired input and output clock frequencies in the
  Static PLL configurator. The mul/div factors can then be read
  out from tool.

Output clock divider, 2nd clock
CONFIG_OCLKB_DIV
  See help for 'Ouput division factor'. Set this to 0 to disable the
  second clock output.

Output clock divider, 3rd clock
CONFIG_OCLKC_DIV
  See help for 'Ouput division factor'. Set this to 0 to disable the
  third clock output.

System clock multiplier
CONFIG_CLKDLL_1_2
  The Xilinx CLKDLL can scale the input clock with a factor of 0.5, 1.0, 
  or 2.0. Useful when the target board has an oscillator with a too high 
  (or low) frequency for your design. The divided clock will be used as the
  main clock for the whole processor (except PCI and ethernet clocks).

System clock multiplier
CONFIG_DCM_2_3
  The Xilinx DCM and Altera ALTDLL can scale the input clock with a large
  range of factors. Useful when the target board has an oscillator with a 
  too high (or low) frequency for your design. The divided clock will
  be used as the main clock for the whole processor (except PCI and 
  ethernet clocks). NOTE: the resulting frequency must be at least
  24 MHz or the DCM and ALTDLL might not work.

Enable CLKDLL for PCI clock
CONFIG_PCI_CLKDLL
  Say Y here to re-synchronize the PCI clock using a 
  Virtex BUFGDLL macro. Will improve PCI clock-to-output 
  delays on the expense of input-setup requirements.

Use PCI clock system clock
CONFIG_PCI_SYSCLK
  Say Y here to the PCI clock to generate the system clock.
  The PCI clock can be scaled using the DCM or CLKDLL to 
  generate a suitable processor clock.

External SDRAM clock feedback
CONFIG_CLK_NOFB
  Say Y here to disable the external clock feedback to synchronize the
  SDRAM clock. This option is necessary if your board or design does not
  have an external clock feedback that is connected to the pllref input
  of the clock generator.

Number of processors
CONFIG_PROC_NUM
  The number of processor cores.

Force values from example configuration
CONFIG_LEON_MIN
  If you select any other value than Custom-configuration then the
  configuration choices will be forced to settings corresponding to
  the selected example configuration. The example configurations are
  described in the document LEON/GRLIB Design and Configuration Guide
  located at doc/guide.pdf.

  Due to limitations in the configuration tool it is not possible to
  update all choices without first saving the configuration and
  restarting the tool. Perform the steps below to set the processor
  configuration to example configuration values: 

  1. Select example configuration (MIN, GP, HP). This will result
     in most processor configuration menus being disabled.
  2. Go back to the main menu and select Save and Exit
  3. Start the xconfig tool again
  4. Go into processor configuration and select Custom-configuration.
     All configuration values can now be changed again and have been
     initialized to example configuration that was selected earlier.
  5. Make any changes and then quit xconfig via Save and Exit

  Some options set from the example configuration may need to be changed.
  One such setting is the FPU multiplier, if the FPU is enabled, where
  timing is improved for several FPGA technologies by selecting the
  technology specific multiplier and where the DW multiplier is generally
  a good choice for ASIC.

  Note that selecting an example configuration will not affect the settings
  for AMBA AHB bus width, cacheability and debug support unit.

Number of SPARC register windows
CONFIG_IU_NWINDOWS
  The SPARC architecture (and LEON) allows 2 - 32 register windows.
  However, any number except 8 will require that you modify and 
  recompile your run-time system or kernel. Unless you know what
  you are doing, use 8.

SPARC V8 multiply and divide instruction
CONFIG_IU_V8MULDIV
  If you say Y here, the SPARC V8 multiply and divide instructions
  will be implemented. The instructions are: UMUL, UMULCC, SMUL,
  SMULCC, UDIV, UDIVCC, SDIV, SDIVCC. In code containing frequent
  integer multiplications and divisions, significant performance
  increase can be achieved. Emulated floating-point operations will
  also benefit from this option.

  By default, the gcc compiler does not emit multiply or divide
  instructions and your code must be compiled with -mv8 to see any
  performance increase. On the other hand, code compiled with -mv8
  will generate an illegal instruction trap when executed on processors
  with this option disabled.

  The divider consumes approximately 2 kgates, the multiplier 6 kgates.

Multiplier latency
CONFIG_IU_MUL_LATENCY_2
  Implementation options for the integer multiplier.
  
  Type        Implementation              issue-rate/latency
  2-clocks    32x32 pipelined multiplier     1/2 
  4-clocks    16x16 standard multiplier      4/4
  5-clocks    16x16 pipelined multiplier     4/5

MAC operation
CONFIG_IU_MUL_MAC
  If you say Y here, the SPARC V8e UMAC/SMAC (multiply-accumulate)
  instructions will be enabled. The instructions implement a
  single-cycle 16x16->32 bits multiply with a 40-bits accumulator.
  The details of these instructions can be found in the LEON manual,
  This option is only available when 16x16 multiplier is used.

Multiplier structure
CONFIG_IU_MUL_INFERRED
  Structure options for the integer multiplier. The multiplier
  can be implemented with the following structures:

  * Inferred by the synthesis tool
  * Generated using Module Generators from NTNU
  * Using technology specific netlists (TechSpec)
  * Using Synopsys Designware (DW02_mult and DW_mult_pipe)

Single vector trapping
CONFIG_IU_SVT
  Single-vector trapping is a SPARC V8e option to reduce code-size
  in small applications. If enabled, the processor will jump to 
  the address of trap 0 (tt = 0x00) for all traps. No trap table
  is then needed. The trap type is present in %psr.tt and must
  be decoded by the O/S. Saves 4 Kbyte of code, but increases
  trap and interrupt overhead. Currently, the only O/S supporting
  this option is eCos. To enable SVT, the O/S must also set bit 13
  in %asr17.

Load latency
CONFIG_IU_LDELAY
  Defines the pipeline load delay (= pipeline cycles before the data
  from a load instruction is available for the next instruction).
  One cycle gives best performance, but might create a critical path
  on targets with slow (data) cache memories. A 2-cycle delay can
  improve timing but will reduce performance with about 5%.

  Note that LEON4 always makes use of load delay 1.

Reset address
CONFIG_IU_RSTADDR
  By default, a SPARC processor starts execution at address 0.
  With this option, any 4-kbyte aligned reset start address can be
  choosen. Keep at 0 unless you really know what you are doing.

Power-down
CONFIG_PWD
  Say Y here to enable the power-down feature of the processor.
  Might reduce the maximum frequency slightly on FPGA targets.
  For details on the power-down operation, see the LEON manual.

Hardware watchpoints
CONFIG_IU_WATCHPOINTS
  The processor can have up to 4 hardware watchpoints, allowing to 
  create both data and instruction breakpoints at any memory location,
  also in PROM. Each watchpoint will use approximately 500 gates.
  Use 0 to disable the watchpoint function.

Floating-point enable
CONFIG_FPU_ENABLE
  Say Y here to enable the floating-point interface for GRFPU-lite
  or GRFPU. Note that no FPU's are provided with the GPL version
  of GRLIB. The FPUs are commercial cores and must be obtained separately. 

FPU selection
CONFIG_FPU_GRFPU
  Select between Gaisler Research's GRFPU and GRFPU-lite FPUs.

GRFPU Multiplier
CONFIG_FPU_GRFPU_INFMUL
  On FPGA targets choose inferred multiplier. For ASIC implementations 
  choose between Synopsys Design Ware (DW) multiplier or Module 
  Generator (ModGen) multiplier. The DW multiplier gives better results 
  (smaller area and better timing) but requires a DW license. 
  The ModGen multiplier is part of GRLIB and does not require a license. 

Shared GRFPU
CONFIG_FPU_GRFPU_SH
  If enabled multiple CPU cores will share one GRFPU.	

GRFPC Configuration
CONFIG_FPU_GRFPC0
  Configures the GRFPU-LITE controller. 

  In simple configuration controller executes FP instructions 
  in parallel with  integer instructions. FP operands are fetched 
  in the register file stage and the result is written in the write 
  stage. This option uses least area resources.

  Data forwarding configuration gives ~ 10 % higher FP performance than 
  the simple configuration by adding data forwarding between the pipeline
  stages. 

  Non-blocking controller allows FP load and store instructions to
  execute in parallel with FP instructions. The performance increase is 
  ~ 20 % for FP applications. This option uses most logic resources and 
  is suitable for ASIC implementations. 
  
Floating-point netlist
CONFIG_FPU_NETLIST
  Say Y here to use a VHDL netlist of the GRFPU-Lite. This is
  only available in certain versions of grlib.

Enable Instruction cache
CONFIG_ICACHE_ENABLE
  The instruction cache should always be enabled to allow
  maximum performance. Some low-end system might want to
  save area and disable the cache, but this will reduce
  the performance with a factor of 2 - 3.

Enable Data cache
CONFIG_DCACHE_ENABLE
  The data cache should always be enabled to allow
  maximum performance. Some low-end system might want to
  save area and disable the cache, but this will reduce
  the performance with a factor of 2 at least.

Instruction cache associativity
CONFIG_ICACHE_ASSO1
  The instruction cache can be implemented as a multi-way cache with
  1 - 4 sets. Higher associativity usually increases the cache hit
  rate and thereby the performance. The downside is higher power
  consumption and increased gate-count for tag comparators.

  Note that a 1-way cache is effectively a direct-mapped cache.

Instruction cache set size
CONFIG_ICACHE_SZ1
  The size of each way in the instuction cache (kbytes). Valid values
  are 1 - 64 in binary steps. Note that the full range is only supported
  by the generic and virtex2 targets. Most target packages are limited
  to 2 - 16 kbyte. A large cache gives higher performance but might
  affect the maximum frequency (on ASIC targets). The total instruction
  cache size is the number of ways multiplied with the way size.

Instruction cache line size
CONFIG_ICACHE_LZ16
  The instruction cache line size. Can be set to either 16 or 32
  bytes per line. Instruction caches typically benefit from larger
  line sizes, but on small caches it migh be better with 16 bytes/line
  to limit eviction miss rate.

Instruction cache replacement algorithm
CONFIG_ICACHE_ALGORND
  Cache replacement algorithm for caches with 2 - 4 sets. The 'Random'
  algorithm selects the way to evict randomly. For LEON4, "Dynamic" option
  makes the replacement policy soft configurable between direct-mapped,
  least-recently-replaced/incremental (LRR), least-recently-used (LRU)
  and random. The replacement policy is then chosen at run-time via the
  cache configuration register(s). The reset value in case 'Dynamic' is
  selected here is LRU. For LEON3, LRU/Dynamic is hard LRU

  The direct-mapped option selects the way based on the address.
  The LRR algorithm evicts the way least recently replaced.
  The LRU algorithm evicts the way least recently accessed.

  The random algorithm uses a simple 1- or 2-bit counter to select
  the eviction way and has low area overhead. The soft configurable
  option with LRU scheme selected has typically the best performance
  but also the highest area overhead. A 2-way LRU uses 1 flip-flop per
  line, a 3-way LRU uses 3 flip-flops per line, and a 4-way LRU uses 5
  flip-flops per line to store the access history.

Instruction cache locking
CONFIG_ICACHE_LOCK
  Say Y here to enable cache locking in the instruction cache.
  Locking can be done on cache-line level, but will increase the
  width of the tag ram with one bit. If you don't know what
  locking is good for, it is safe to say N.

Data cache associativity
CONFIG_DCACHE_ASSO1
  The data cache can be implemented as a multi-way cache with
  1 - 4 sets. Higher associativity usually increases the cache hit
  rate and thereby the performance. The downside is higher power
  consumption and increased gate-count for tag comparators.

  Note that a 1-way cache is effectively a direct-mapped cache.

  If the MMU is enabled then bus snooping is required to avoid
  aliasing effects in multi-way caches.

Data cache way size
CONFIG_DCACHE_SZ1
  The size of each way in the data cache (kbytes). Valid values are
  1 - 64 in binary steps. Note that the full range is only supported
  by the generic and virtex2 targets. Most target packages are limited
  to 2 - 16 kbyte. A large cache gives higher performance but the
  data cache is timing critical an a too large setting might affect
  the maximum frequency (on ASIC targets). The total data cache size
  is the number of ways multiplied with the way size.

  Note that when the MMU is enabled, bus snooping should also be
  enabled and the data cache way size should not exceed the MMU
  page size.

Data cache line size
CONFIG_DCACHE_LZ16
  The data cache line size. Can be set to either 16 or 32 bytes per
  line. A smaller line size gives better associativity and higher
  cache hit rate, but requires a larger tag memory.

Data cache replacement algorithm
CONFIG_DCACHE_ALGORND
  See the explanation for instruction cache replacement algorithm.

Data cache locking
CONFIG_DCACHE_LOCK
  Say Y here to enable cache locking in the data cache.
  Locking can be done on cache-line level, but will increase the
  width of the tag ram with one bit. If you don't know what
  locking is good for, it is safe to say N.

Data cache snooping
CONFIG_DCACHE_SNOOP
  Say Y here to enable data cache snooping on the AHB bus.

  With snooping, AHB writes by other masters to data that is in the
  data cache will be automatically detected and the cache line will
  be marked as invalid. This simplifies software design in systems
  with DMA units or multiple processors accessing the same memory.
  It is a requirement (together with separate snoop tags) to run
  Linux on more than one CPU.

  Depending on the separate snoop tags option, snooping will be
  implemented using either dual-port (common tags) or two-port
  RAMs (separate tags). A workaround if dual port RAMs are
  not available for the target technology is to use separate
  snoop tags even if it is not needed otherwise.

Separate snoop tags
CONFIG_DCACHE_SNOOP_SEPTAG
  Enable a separate memory to store the data tags used for snooping.
  This is necessary when snooping support is wanted in systems
  with MMU, typically for SMP systems. In this case, the snoop
  tags will contain the physical tag address while the normal
  tags contain the virtual tag address.

  When separate snoop tags are enabled, the tag RAMs will be implemented
  using two-port RAMs instead of dual-port RAMs. A workaround if
  dual port RAMs are not available for the target technology is
  therefore to use separate snoop tags even if it is not needed.

Single-port RAM for separate tags
CONFIG_DCACHE_SNOOP_SP
  Use single-port RAM to implement separate physical tags. This leads
  to the cache tag valid bits being implemented in flip-flops.

Fixed cacheability map
CONFIG_CACHE_FIXED
  If this variable is 0, the cacheable memory regions are defined
  by the AHB plug&play information (default). To overriden the
  plug&play settings, this variable can be set to indicate which
  areas should be cached. The value is treated as a 16-bit hex value
  with each bit defining if a 256 Mbyte segment should be cached or not.
  The right-most (LSB) bit defines the cacheability of AHB address
  0 - 256 MByte, while the left-most bit (MSB) defines AHB address
  3840 - 4096 MByte. If the bit is set, the corresponding area is
  cacheable. A value of 00F3 defines address 0 - 0x20000000 and
  0x40000000 - 0x80000000 as cacheable.

Local data ram
CONFIG_DCACHE_LRAM
  Say Y here to add a local ram to the data cache controller.
  Accesses to the ram (load/store) will be performed at 0 waitstates
  and store data will never be written back to the AHB bus.

Size of local data ram
CONFIG_DCACHE_LRAM_SZ1
  Defines the size of the local data ram in Kbytes. Note that most
  technology libraries do not support larger rams than 16 Kbyte.

Start address of local data ram
CONFIG_DCACHE_LRSTART
  Defines the 8 MSB bits of start address of the local data ram.
  By default set to 8f (start address = 0x8f000000), but any value
  (except 0) is possible. Note that the local data ram 'shadows'
  a 16 Mbyte block of the address space.

MMU enable
CONFIG_MMU_ENABLE
  Say Y here to enable the Memory Management Unit.

MMU split icache/dcache table lookaside buffer
CONFIG_MMU_COMBINED
  Select "combined" for a combined icache/dcache table lookaside buffer,
  "split" for a split icache/dcache table lookaside buffer

MMU tlb replacement scheme
CONFIG_MMU_REPARRAY
  Select "LRU" to use the "least recently used" algorithm for TLB
  replacement, or "Increment" for a simple incremental replacement
  scheme.

Combined i/dcache tlb
CONFIG_MMU_I2
  Select the number of entries for the instruction TLB, or the
  combined icache/dcache TLB if such is used.

Split tlb, dcache
CONFIG_MMU_D2
  Select the number of entries for the dcache TLB.

Fast writebuffer 
CONFIG_MMU_FASTWB
  Only selectable if split tlb is enabled. In case fast writebuffer is
  enabled the tlb hit will be made concurrent to the cache hit. This 
  leads to higher store performance, but increased power and area.

MMU pagesize
CONFIG_MMU_PAGE_4K
  The deafult SPARC V8 SRMMU page size is 4 Kbyte. This limits the
  cache way size to 4 Kbyte, and total data cache size to 16 Kbyte,
  when the MMU is used. To increase the maximum data cache size,
  the MMU pages size can be increased to up 32 Kbyte. This will
  give a maximum data cache size of 128 Kbyte.

  Note that an MMU page size different than 4 Kbyte will require
  a special linux tool-chain if glibc is used. If you don't know
  what you are doing, stay with 4 Kbyte.

DSU enable
CONFIG_DSU_ENABLE
  The debug support unit (DSU) allows non-intrusive debugging and tracing
  of both executed instructions and AHB transfers. If you want to enable
  the DSU, say Y here and select the configuration below.

Trace buffer enable
CONFIG_DSU_TRACEBUF
  Say Y to enable the trace buffer. The buffer is not necessary for
  debugging, only for tracing instructions and data transfers.

Enable instruction tracing
CONFIG_DSU_ITRACE
  If you say Y here, an instruction trace buffer will be implemented
  in each processor. The trace buffer will trace executed instructions
  and their results, and place them in a circular buffer. The buffer 
  can be read out by any AHB master, and in particular by the debug 
  communication link.

Size of trace buffer
CONFIG_DSU_ITRACESZ1
  Select the buffer size (in kbytes) for the instruction trace buffer. 
  Each line in the buffer needs 16 bytes. A 128-entry buffer will thus
  need 2 kbyte.

Enable two-port instruction trace buffer
CONFIG_DSU_ITRACE_2P
  If you say Y here, the instruction trace buffer will be implemented
  in each processor with a two-port RAM. It will then be possible
  to read the buffer through its second port, while the processor 
  instructions are being traced.

Enable AHB tracing
CONFIG_DSU_ATRACE
  If you say Y here, an AHB trace buffer will be implemented in the
  debug support unit processor. The AHB buffer will trace all transfers
  on the AHB bus and save them in a circular buffer. The trace buffer 
  can be read out by any AHB master, and in particular by the debug 
  communication link.

Size of trace buffer
CONFIG_DSU_ATRACESZ1
  Select the buffer size (in kbytes) for the AHB trace buffer. 
  Each line in the buffer needs 16 bytes. A 128-entry buffer will thus
  need 2 kbyte.

AHB data breakpoints
CONFIG_DSU_AHBWP2
 Selects if AHB data breakpoints should be enabled. Pipelined option
 is best for timing but has an overhead in area. Selecting just
 Enabled prevents inclusion of pipeline registers but may cause long
 timing paths between the AMBA AHB data vectors and the DSU.
 The recommended setting is pipelined unless system frequency and
 available area is low.

AHB trace buffer filters
CONFIG_DSU_AFILT
  If you say Y here, the debug support unit will allow filtering of
  AHB trace buffer inputs. Filters allow to select which masters,
  slaves and types of accesses that should be saved to the buffer.

AHB statistics outputs
CONFIG_DSU_ASTAT
  If you say Y here, the debug support unit will enable its statistics
  outputs. These outputs can be connected to a L4STAT unit in order to
  count events on the AHB bus. This option will also enable AHB trace
  buffer filters.

LEON-FT enable
CONFIG_LEONFT_EN
  Say Y here to use the fault-tolerant LEON-FT core instead of the
  standard non-FT LEON.

IU Register file protection 
CONFIG_IUFT_NONE
  Select the FT implementation in the LEONFT integer unit 
  register file.

  For LEON3FT the options are: none. parity, parity with sparing,
  7-bit BCH, 7-bit BCH with on-the-fly (OTF) correction,
  technology-specific protection and TMR.

  For LEON4FT the options are none and TMR.

FPU Register file protection 
CONFIG_FPUFT_EN
  Say Y to enable SEU protection of the FPU register file.
  The GRFPU will be protected using 8-bit parity without restart, while
  the GRFPU-Lite will be protected with 4-bit parity with restart. If 
  disabled the FPU register file will be implemented using flip-flops.

Cache memory error injection
CONFIG_RF_ERRINJ
  Say Y here to enable error injection in to the IU/FPU regfiles.
  Affects only simulation.

Cache memory protection 
CONFIG_CACHE_FT_NONE
  Enable SEU error-correction in the cache memories.

  None - No protection
  Parity     - Technology agnostic parity protection
  SECDEC-BCH - SECDED for cache, slow and large area overhead
  TechSpec   - Use target technology protection

  The recommended setting is Parity. Target technologies
  with built in protection on SRAMs can have area savings
  with TechSpec. Currently this option should only be used
  for Microsemi RTG4.

Cache memory error injection
CONFIG_CACHE_ERRINJ
  Say Y here to enable error injection in to the cache memories.
  Affects only simulation.

LEON netlist
CONFIG_LEON_NETLIST
  Say Y here to use a VHDL netlist of the LEON. This is
  only available in certain versions of grlib.

IU assembly printing
CONFIG_IU_DISAS
  Enable printing of executed instructions to the console.

IU assembly printing in netlist
CONFIG_IU_DISAS_NET
  Enable printing of executed instructions to the console also
  when simulating a netlist. NOTE: with this option enabled, it
  will not be possible to pass place&route.

32-bit program counters
CONFIG_DEBUG_PC32
  Since the LSB 2 bits of the program counters always are zero, they are
  normally not implemented. If you say Y here, the program counters will
  be implemented with full 32 bits, making debugging of the VHDL model
  much easier. Turn of this option for synthesis or you will be wasting
  area.

LEON Statistical Module
CONFIG_STAT_ENABLE
  Say Y here to enable the LEON Statistical Unit. The unit consists
  of a number of timers that can count various processor and MMU/FPU
  events to allow analysis of processor behavior and performance. 

Number of L4S counters
CONFIG_STAT_CNT 
  Set the number of 32-bit counters in the unit (1 - 32).

Number of L4S accumulative counters
CONFIG_STAT_NMAX
  If this value is higher than 0, the core will include functionality 
  for tracking the longest consecutive time that an event is active or 
  inactive. The functionality will be available for the nmax first 
  counters. This value must not exceed the number of available counters.

SPARC V8E non-privileged ASI access
CONFIG_NP_ASI
  In SPARC-V8E implementations providing for non-privileged ASI access
  functions, LOAD and STORE from Alternate space instructions
  accessing ASI’s 0016 - 7F16 are privileged instructions. LOAD and
  STORE from Alternate space instructions accessing ASI’s 8016 - FF16
  are non-privileged instructions. This option enables this non-
  privileged behavior.
L2 Associativity
CONFIG_L2_ASSO1
  Select how many cache ways the L2 cache should have.

L2 Way size
CONFIG_L2_SZ1
  Select the szie of each way in kbytes. The total L2 cache
  size will be way size * number of ways.

L2 cache line size
CONFIG_L2_LINE16
  The L2 cache can have either 16 or 32 bytes per line. It is
  recommened to use 32 bytes for best performance.

HPROT cachebility decoding
CONFIG_L2_HPROT
  Say yes here to enable the AHB HPROT signals to define if an
  L2 access should be cached. Should be disabled for now until
  all I/O units in grlib generate these signals correctly.

L2 power-on enable
CONFIG_L2_PEN
  Say yes here to enable the L2 cache directly after reset.
  This will allow to use the cache without first enable it
  in software. The cache will automatically be flushed before
  enabled.

Random replacement
CONFIG_L2_RAN
  Say Y here to enable random replacement policy rather then
  the default LRU.

Write-through operation
CONFIG_L2_WT
  The L2 cache operates by default in copy-back mode. Say yes
  here to enable write-through operation at power-on.

Cachebility mapping
CONFIG_L2_MAP
  This 16-bit hexadecimal vaule defines which address areas
  are to be cacheable by the L2 cache. Each bit set indicates
  a cacheable 256 Mbyte block. The left-most bit (LSB) indicates
  address 0 - 256M and so on.

RAM sharing
CONFIG_L2_SHARE
  Say yes here to implement one shared data RAM for all cache ways.
  This will reduce the number of RAM blocks for multi-way caches.

MTRR registers
CONFIG_L2_MTRR
  Specify the number of MTRR registers. Each MTRR can define one
  memory area to be uncached, write-through, or copy-back.

EDAC protection
CONFIG_L2_EDAC
  Say yes here to enable EDAC protection.

AXI backend interface
CONFIG_L2_AXI
  Say yes here to enable AXI backend interface
CONFIG_AHB_DEFMST
  Sets the default AHB master (see AMBA 2.0 specification for definition).
  Should not be set to a value larger than the number of AHB masters - 1.
  For highest processor performance, leave it at 0.

Default AHB master
CONFIG_AHB_RROBIN
  Say Y here to enable round-robin arbitration of the AHB bus. A N will
  select fixed priority, with the master with the highest bus index having
  the highest priority.

Support AHB split-transactions
CONFIG_AHB_SPLIT
  Say Y here to enable AHB split-transaction support in the AHB arbiter.
  Unless you actually have an AHB slave that can generate AHB split
  responses, say N and save some gates.

Enable full PnP decoding
CONFIG_AHB_FPNPEN
  Say Y here to enable full decoding of the PnP configuration records in
  in the AHB arbiter. When disabled the user-defined registers in the
  PnP configuration records are not mapped in the configuration area.

IO area start address
CONFIG_AHB_IOADDR
  Selects the MSB adddress (HADDR[31:20]) of the AHB IO area, as defined 
  in the plug&play extentions of the AMBA bus. Should be kept to FFF 
  unless you really know what you are doing.

APB bridge address          
CONFIG_APB_HADDR
  Selects the MSB adddress (HADDR[31:20]) of the APB bridge. Should be
  kept at 800 for software compatibility. 

AHB monitor                 
CONFIG_AHB_MON
  Say Y to enable the AHB bus monitor. The monitor will check for
  illegal AHB transactions during simulation. It has no impact on
  synthesis.

Report AHB errors
CONFIG_AHB_MONERR
  Print out detected AHB violations on console.

Report AHB warnings
CONFIG_AHB_MONWAR
  Print out detected AHB warnings on console.

Write trace to console
CONFIG_AHB_DTRACE
  Say yes here to write a trace of all AHB transfers to the
  simulator console. Has not impact on final netlist.

DSU enable
CONFIG_DSU_UART
  Say Y to enable the AHB uart (serial-to-AHB). This is the most
  commonly used debug communication link.

JTAG Enable
CONFIG_DSU_JTAG
  Say Y to enable the JTAG debug link (JTAG-to-AHB). Debugging is done 
  with GRMON through the boards JTAG chain at speeds of up to 800 kbits/s. 

  The TAP controller can be implemented in custom macros on
  Altera, Actel Proasic/3 and Xilinx devices. The commercial
  GRLIB also includes a generic TAP controller in VHDL.

  Supported JTAG cables are Xilinx Parallel Cable III and IV, 
  Xilinx Platform cables (USB), and Altera parallel and USB cables,
  Amontech JTAG key, various FTDI chip based USB/JTAG devices, and
  Actel Flash Pro 3/4 cable.

USB DSU enable
CONFIG_GRUSB_DCL
  Say Y to enable the USB Debug Communication Link

CONFIG_GRUSB_DCL_ULPI
  Select the interface of the USB transceiver that the USBDCL will be
  connected to.
Ethernet DSU enable
CONFIG_DSU_ETH
  Say Y to enable the Ethernet Debug Communication Link (EDCL). The link
  provides a DSU gateway between ethernet and the AHB bus. Debugging is
  done at 10 or 100 Mbit/s, using the GRMON debug monitor. You must
  enable the GRETH Ethernet MAC for this option to become active.

Size of EDCL trace buffer
CONFIG_DSU_ETHSZ1
  Select the buffer size (in kbytes) for the EDCL. 1 or 2 kbyte is
  usually enough, while a larger buffer will increase the transfer rate.
  When operating at 100 Mbit, use a buffer size of at least 8 kbyte for
  maximum throughput.

MSB IP address
CONFIG_DSU_IPMSB
  Set the MSB 16 bits of the IP address of the EDCL.

LSB IP address
CONFIG_DSU_IPLSB
  Set the LSB 16 bits of the IP address of the EDCL.

MSB ethernet address
CONFIG_DSU_ETHMSB
  Set the MSB 24 bits of the ethernet address of the EDCL.

LSB ethernet address
CONFIG_DSU_ETHLSB
  Set the LSB 24 bits of the ethernet address of the EDCL.

Programmable MAC/IP address
CONFIG_DSU_ETH_PROG
  Say Y to make the LSB 4 bits of the EDCL MAC and IP address
  configurable using the ethi.edcladdr inputs.
Leon2 memory controller
CONFIG_MCTRL_LEON2
  Say Y here to enable the LEON2 memory controller. The controller
  can access PROM, I/O, SRAM and SDRAM. The bus width for PROM
  and SRAM is programmable to 8-, 16- or 32-bits.

8-bit memory support
CONFIG_MCTRL_8BIT
  If you say Y here, the PROM/SRAM memory controller will support
  8-bit mode, i.e. operate from 8-bit devices as if they were 32-bit.
  Say N to save a few hundred gates.

16-bit memory support
CONFIG_MCTRL_16BIT
  If you say Y here, the PROM/SRAM memory controller will support
  16-bit mode, i.e. operate from 16-bit devices as if they were 32-bit.
  Say N to save a few hundred gates.

Write strobe feedback
CONFIG_MCTRL_WFB
  If you say Y here, the PROM/SRAM write strobes (WRITEN, WEN) will
  be used to enable the data bus drivers during write cycles. This
  will guarantee that the data is still valid on the rising edge of
  the write strobe. If you say N, the write strobes and the data bus
  drivers will be clocked on the rising edge, potentially creating
  a hold time problem in external memory or I/O. However, in all
  practical cases, there is enough capacitance in the data bus lines
  to keep the value stable for a few (many?) nano-seconds after the
  buffers have been disabled, making it safe to say N and remove a 
  combinational path in the netlist that might be difficult to 
  analyze.

Write strobe feedback
CONFIG_MCTRL_5CS
  If you say Y here, the 5th (RAMSN[4]) SRAM chip select signal will
  be enabled. If you don't intend to use it, say N and save some gates.

SDRAM controller enable
CONFIG_MCTRL_SDRAM
  Say Y here to enabled the PC100/PC133 SDRAM controller. If you don't
  intend to use SDRAM, say N and save about 1 kgates.

SDRAM controller inverted clock
CONFIG_MCTRL_SDRAM_INVCLK
  If you say Y here, the SDRAM controller output signals will be delayed
  with 1/2 clock in respect to the SDRAM clock. This will allow the used
  of an SDRAM clock which in not strictly in phase with the internal 
  clock. This option will limit the SDRAM frequency to 40 - 50 MHz.

  On FPGA targets without SDRAM clock synchronizations through PLL/DLL, 
  say Y. On ASIC targets, say N and tell your foundry to balance the 
  SDRAM clock output.

SDRAM separate address buses
CONFIG_MCTRL_SDRAM_SEPBUS
  Say Y here if your SDRAM is connected through separate address
  and data buses (SA & SD). This is the case on the GR-CPCI-XC2V6000
  board, but not on the GR-PCI-XC2V3000 or Avnet XCV1500E boards.

64-bit data bus
CONFIG_MCTRL_SDRAM_BUS64
  Say Y here to enable 64-bit SDRAM data bus.

Page burst enable
CONFIG_MCTRL_PAGE
  Say Y here to enable SDRAM page burst operation. This will implement
  read operations using page bursts rather than 8-word bursts and save
  about 500 gates (100 LUTs). Note that not all SDRAM supports page 
  burst, so use this option with care.

Programmable page burst enable
CONFIG_MCTRL_PROGPAGE
  Say Y here to enable programmable SDRAM page burst operation. This
  will allow to dynamically enable/disable page burst by setting
  bit 17 in MCFG2.

AHB status register
CONFIG_AHBSTAT_ENABLE
  Say Y here to enable the AHB status register (AHBSTAT IP).
  The register will latch the AHB address and master index when
  an error response is returned by any AHB slave.

SDRAM separate address buses
CONFIG_AHBSTAT_NFTSLV
  The AHB status register can also latch the AHB address on an external
  input. Select here how many of such inputs are required.

On-chip rom
CONFIG_AHBROM_ENABLE
  Say Y here to add a block on on-chip rom to the AHB bus. The ram
  provides 0-waitstates read access,  burst support, and 8-, 16- 
  and 32-bit data size. The rom will be syntheised into block rams
  on Xilinx and Altera FPGA devices, and into gates on ASIC 
  technologies. GRLIB includes a utility to automatically create
  the rom VHDL model (ahbrom.vhd) from an ELF file. Refer to the GRLIB
  documentation for details.

On-chip rom address
CONFIG_AHBROM_START
  Set the start address of AHB ROM (HADDR[31:20]). The ROM will occupy
  a 1 Mbyte slot at the selected address. Default is 000, corresponding
  to AHB address 0x00000000. When address 0x0 is selected, the rom area
  of any other memory controller is set to 0x10000000 to avoid conflicts.

Enable pipeline register for on-chip rom
CONFIG_AHBROM_PIPE
  Say Y here to add a data pipeline register to the on-chip rom.
  This should be done when the rom is implemenented in (ASIC) gates,
  or in logic cells on FPGAs. Do not use this option when the rom is
  implemented in block rams. If enabled, the rom will operate with 
  one waitstate.

On-chip ram
CONFIG_AHBRAM_ENABLE
  Say Y here to add a block on on-chip ram to the AHB bus. The ram
  provides 0-waitstates read access and 0/1 waitstates write access.
  All AHB burst types are supported, as well as 8-, 16- and 32-bit
  data size.

On-chip ram size
CONFIG_AHBRAM_SZ1
  Set the size of the on-chip AHB ram. The ram is infered/instantiated
  as four byte-wide ram slices to allow byte and half-word write
  accesses. It is therefore essential that the target package can
  infer byte-wide rams. This is currently supported on the generic,
  virtex, virtex2, proasic and axellerator targets.

On-chip ram address
CONFIG_AHBRAM_START
  Set the start address of AHB RAM (HADDR[31:20]). The RAM will occupy
  a 1 Mbyte slot at the selected address. Default is A00, corresponding
  to AHB address 0xA0000000.

On-chip ram pipeline stage
CONFIG_AHBRAM_PIPE
  Set this option to add an extra pipeline stage to the read data of the 
  on-chip RAM. This can improve timing, especially when the memory is 
  large, at the cost of adding an additional cycle delay on read.
Gaisler Ethernet MAC enable
CONFIG_GRETH_ENABLE
  Say Y here to enable the Gaisler Research Ethernet MAC . The MAC has 
  one AHB master interface to read and write packets to memory, and one
  APB slave interface for accessing the control registers. 

Gaisler Ethernet 1G MAC enable
CONFIG_GRETH_GIGA
  Say Y here to enable the Gaisler Research 1000 Mbit Ethernet MAC . 
  The 1G MAC is only available in the commercial version of GRLIB,
  so do NOT enable it if you are using the GPL version.

CONFIG_GRETH_FIFO4
  Set the depth of the receive and transmit FIFOs in the MAC core.
  The MAC core will perform AHB burst read/writes with half the
  size of the FIFO depth.

CONFIG_GRETH_FT
  Enable fault-tolerance (parity with sparing) for internal RAM
  in Ethernet core. Note that FT for EDCL buffer is enabled via
  separate setting.

CONFIG_GRETH_EDCLFT
  Enable protection for EDCL buffer. This is typically not used as
  the EDCL debug link is not used in harsh environments.
Gaisler USB 2.0 Host Controller enable
CONFIG_GRUSBHC_ENABLE
  Say Y here to enable the Gaisler Research USB 2.0 Host Controller.
  The core contains one EHCI controller which can be configured to
  contain 0 to 15 UHCI companion controllers. The controller can also
  be configured to exclude the EHCI controller. The EHCI controller
  contains one AHB master interface to access memory and one APB slave
  for accessing control registers. The UHCI controller contains one AHB
  master interface for accessing memory and one AHB slave interface for
  accessing control registers.

Gaisler Enhanced Host Controller enable
CONFIG_GRUSBHC_EHC
  Say Y here to enable the Gaisler Research Enhanced Host Controller.
  This USB 2.0 controller implements the Enhanced Host Controller 
  Interface and supports High-Speed USB traffic. 

Gaisler Universal Host Controller enable
CONFIG_GRUSBHC_UHC
  Say Y here to enable the Gaisler Research Universal Host Controller.
  This USB 1.1 controller implements the Universal Host Controller
  Interface and supports Full- and Low-Speed USB traffic. Controllers
  of this type will be configured as companion controllers if the
  Enhanced Host Controller is enabled.

CONFIG_GRUSBHC_NCC
  Number of companion (universal) host controllers. A universal host
  controller may handle up to fifteen ports. Some designers choose
  to implement one universal host controller per port. If you are
  unsure, set this value to 1 to let one controller handle all ports.
  
CONFIG_GRUSBHC_NPORTS
  Number of transceivers connected to the core.

CONFIG_GRUSBHC_ULPI
  Select the interface of the transceiver(s) that the core will be
  connected to.

CONFIG_GRUSBHC_VBUSEXT
  Selects the source for bus power generation. Select External if
  external USB power switch is used (recommended for USB hosts) or
  select Internal if not USB power switch is present and ULPI
  transceiver should generate VBUS.  

CONFIG_GRUSBHC_FAULTL
  Selects active level of fault signal from external USB power switch.
  Select None if the external USB power switch doesn't have fault 
  detection.

CONFIG_GRUSBHC_ENABLEH
  Selects the active level of the outgoing vbus enable signal
  (connected between the core's drvvbus output and a USB power switch
  enable input). The UTMI+ specification defines the drvvbus signal to be
  active high, but GRUSBHC can be configured with an active low
  drvvbus in order to support more USB power switches without the
  need for an external inverter.

CONFIG_GRUSBHC_FAULT2H
  Selects the active level of the incoming vbus valid indicator
  (connected between the core's vbusvalid input and a USB power switch
  fault ouput). The UTMI+ specification defines the vbusvalid signal to be
  active high, but GRUSBHC can be configured with an active low
  vbusvalid in order to support more USB power switches without the
  need for an external inverter.

CONFIG_GRUSBHC_ENDIAN
  The host controller works internally with little endian. If the
  controller is connected to a big endian bus (such as the AMBA bus
  in GRLIB) endian conversion must be enabled.

CONFIG_GRUSBHC_BEREGS
  With this option enabled the register space will be arranged 
  according to big endian addressing. If this option is 
  not enabled the register space of both controllers will be
  byte swapped. See the IP core user's manual for details.

CONFIG_GRUSBHC_BEDESC
  With this option enabled the in-memory transfer descriptors will
  be in big endian format. Without this option software must byte 
  swap all descriptors.

CONFIG_GRUSBHC_BWRD
  Maximum burst length in words.

CONFIG_GRUSBHC_NPCC
  Number of ports per companion controller. This option must be 
  consistent with number of ports and number of companion 
  controllers. Number of companion controller multiplied with 
  this value may not be less than the total number of ports. 
  In addition, there can not be a companion controller that is left 
  without ports.

CONFIG_GRUSBHC_PRR
  If CONFIG_GRUSBHC_PRR are disabled the lowest CONFIG_GRUSBHC_NPCC
  ports are routed to the lowest numbered companion controller and
  so on. If CONFIG_GRUSBHC_PRR is enabled each port can be 
  individually routed to a specific companion controller. 


CONFIG_GRUSBHC_PR1
  The companion controller that port 1 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR2
  The companion controller that port 2 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR3
  The companion controller that port 3 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR4
  The companion controller that port 4 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR5
  The companion controller that port 5 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR6
  The companion controller that port 6 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR7
  The companion controller that port 7 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR8
  The companion controller that port 8 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR9
  The companion controller that port 9 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR10
  The companion controller that port 10 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR11
  The companion controller that port 11 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR12
  The companion controller that port 12 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR13
  The companion controller that port 13 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR14
  The companion controller that port 14 should be routed to. Unused
  ports should have their value set to 0.

CONFIG_GRUSBHC_PR15
  The companion controller that port 15 should be routed to. Unused
  ports should have their value set to 0.

Gaisler Research USB 2.0 Device Controller enable
CONFIG_GRUSBDC_ENABLE
  Say Y here to enable the Gaisler Research USB 2.0 Device Controller.
  The core can be configured with 1-16 IN endpoints and 1-16 OUT 
  endpoints (including endpoint zero). The core use an AHB slave
  interface for configuration. For data transfers the the user have the
  option of adding an AHB master interface for DMA, or to use the slave
  interface. The core supports 8-bit and 16-bit UTMI/UTMI+ and 
  ULPI interfaces towards the USB transceiver.

CONFIG_GRUSBDC_AHBMST
  Say Y here to enable the AHB master interface and DMA. When master
  interface is disabled all data transfers are handled with the AHB
  slave interface.

CONFIG_GRUSBDC_ULPI
  Select the interface of the USB transceiver that the core will be
  connected to.

CONFIG_GRUSBDC_NEPI
  Select number of IN endpoints (including endpoint zero).
  Valid range is 1 - 16.

CONFIG_GRUSBDC_NEPO
  Select number of OUT endpoints (including endpoint zero).
  Valid range is 1 - 16.

CONFIG_GRUSBDC_I0
  Select buffer size (in bytes) for IN endpoint 0.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O0
  Select buffer size (in bytes) for OUT endpoint 0.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I1
  Select buffer size (in bytes) for IN endpoint 1.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O1
  Select buffer size (in bytes) for OUT endpoint 1.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I2
  Select buffer size (in bytes) for IN endpoint 2.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O2
  Select buffer size (in bytes) for OUT endpoint 2.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I3
  Select buffer size (in bytes) for IN endpoint 3.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O3
  Select buffer size (in bytes) for OUT endpoint 3.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I4
  Select buffer size (in bytes) for IN endpoint 4.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O4
  Select buffer size (in bytes) for OUT endpoint 4.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I5
  Select buffer size (in bytes) for IN endpoint 5.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O5
  Select buffer size (in bytes) for OUT endpoint 5.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I6
  Select buffer size (in bytes) for IN endpoint 6.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O6
  Select buffer size (in bytes) for OUT endpoint 6.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I7
  Select buffer size (in bytes) for IN endpoint 7.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O7
  Select buffer size (in bytes) for OUT endpoint 7.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I8
  Select buffer size (in bytes) for IN endpoint 8.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O8
  Select buffer size (in bytes) for OUT endpoint 8.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I9
  Select buffer size (in bytes) for IN endpoint 9.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O9
  Select buffer size (in bytes) for OUT endpoint 9.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I10
  Select buffer size (in bytes) for IN endpoint 10.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O10
  Select buffer size (in bytes) for OUT endpoint 10.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I11
  Select buffer size (in bytes) for IN endpoint 11.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O11
  Select buffer size (in bytes) for OUT endpoint 11.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I12
  Select buffer size (in bytes) for IN endpoint 12.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O12
  Select buffer size (in bytes) for OUT endpoint 12.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I13
  Select buffer size (in bytes) for IN endpoint 13.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O13
  Select buffer size (in bytes) for OUT endpoint 13.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I14
  Select buffer size (in bytes) for IN endpoint 14.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O14
  Select buffer size (in bytes) for OUT endpoint 14.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_I15
  Select buffer size (in bytes) for IN endpoint 15.
  Valid range is 8 - 3072.

CONFIG_GRUSBDC_O15
  Select buffer size (in bytes) for OUT endpoint 15.
  Valid range is 8 - 3072.

CAN interface enable
CONFIG_CAN_ENABLE
  Say Y here to enable one or more CAN cores. The cores has one
  AHB slave interface for accessing the control registers. The CAN core
  is register-compatible with the SAJ1000 core from Philips, with a
  few exceptions. See the GRLIP IP manual for details.

CONFIG_CAN_NUM
  Number of CAN cores. The module allows up to 8 independent
  CAN cores to be implemented.

CAN register address
CONFIG_CANIO
  The control registers of each CAN core occupies 256 bytes, and 
  address space needed for the full module is thus 2 Kbyte. The cores
  are mapped in the AHB bus I/O area (0xFFF00000 - 0xFFFFF000). 
  This setting defines at which address in the I/O area the registers
  appear (HADDR[19:8]).

CAN interrupt
CONFIG_CANIRQ
  Defines which interrupt number the CAN core will generate.

CAN interrupt
CONFIG_CANSEPIRQ
  Say Y here to assign an individual interrupt to each CAN core,
  starting from the base interrupt number. If set to N, all
  CAN cores will generate the same interrupt.

CAN FT memories
CONFIG_CAN_FT
  If you say Y here, the CAN FIFOs will be implemented using
  SEU protected RAM blocks. Only applicable to the FT version
  of grlib.

CAN Synchronous reset
CONFIG_CAN_SYNCRST
  If you say Y here, the CAN core will be implemented with
  synchronous reset rather than asynchronous. This is needed
  when the target library does not implement registers with
  async reset. Unless you know what you are doing, say N.

Spacewire link
CONFIG_SPW_ENABLE
  Say Y here to enable one or more Spacewire serial links. The links
  are based on the GRSPW core from Gaisler Research.

Number of spacewire links
CONFIG_SPW_NUM
  Select the number of links to implement. Each link will be a
  separate AHB master and APB slave for configuration.

AHB FIFO depth
CONFIG_SPW_AHBFIFO4
  Select the AHB FIFO depth (in 32-bit words).

RX FIFO depth
CONFIG_SPW_RXFIFO16
  Select the receiver FIFO depth (in bytes).

RMAP protocol
CONFIG_SPW_RMAP
  Enable hardware target support for the RMAP protocol (
  draft C for GRSPW1 and ECSS-E-ST-50-11C Draft V1.3 
  for GRSPW2).

RMAP Buffer depth
CONFIG_SPW_RMAPBUF2
  Select the size of the RMAP buffer (in bytes).

RMAP CRC
CONFIG_SPW_RMAPCRC
  Enable hardware calculation of the RMAP CRC checksum. RMAP CRC
  is always enabled when the RMAP hardware target is enabled so this
  parameter will have no effect in that case.

Rx unaligned
CONFIG_SPW_RXUNAL
  Enable support for byte writes used for non word-aligned 
  receiver buffer addresses. Without this enabled data will
  still be written at the correct location but complete words
  will always be written so data outside the intended boundaries
  might be overwritten.

Netlists
CONFIG_SPW_NETLIST
  Use the netlist version of GRSPW. This option is required if
  you have not licensed the source code of the Spacewire core.
  Currently only supported for Xilinx and Actel FPGAs.
  The AHB/RX FIFO sizes should be set to 16 word/byte. If the
  RMAP is enabled, set the buffer size to 128 bytes. Other netlist
  configurations can be requested from Gaisler Research.

Spacewire FT
CONFIG_SPW_FT
  Say Y here to implement the Spacewire block rams with fault-tolerance
  against SEU errors.

Spacewire core
CONFIG_SPW_GRSPW1
  Select to use GRSPW1 core or GRSPW2 core.

DMA channels
CONFIG_SPW_DMACHAN
  Set the number of DMA channels for the GRSPW2 core.
  Set to 1 for now ...

Ports
CONFIG_SPW_PORTS
  Set the number of SpaceWire ports for the GRSPW2 core

Same clock for SpaceWire receiver and transmitter
CONFIG_SPW_RTSAME            
  Say Y here if the same clock is connected to both the receiver
  and transmitter in the GRSPW2 core. This will remove two
  asynchronous resets and some synchronization logic. This is only
  applicable for the SDR and DDR inputs modes.


Receiver clock type
CONFIG_SPW_RX_SDR
  Selects the input clocking scheme for the GRSPW2. SDR means that the
  core samples data and strobe using single data rate registers at the
  receiver clock frequency. DDR is the same except DDR registers are used.
  Xor selects the traditional self clocking scheme using a xor gate. 
  Aeroflex sets the receiver in a mode compatible with the Aeroflex
  SpaceWire transceiver.

Receiver clock type
CONFIG_SPW_TX_SDR
  Selects the output clocking scheme for the GRSPW2. SDR means that the
  core transmits data and strobe using single data rate registers at the
  transmitter clock frequency. DDR is the same except DDR registers are used.
  Aeroflex sets the transmitter in a mode compatible with the Aeroflex
  SpaceWire transceiver.
UART1 enable
CONFIG_UART1_ENABLE
  Say Y here to enable UART1, or the console UART. This is needed to
  get any print-out from LEON3 systems regardless of operating system.

UART1 FIFO
CONFIG_UA1_FIFO1
  The UART has configurable transmitt and receive FIFO's, which can
  be set to 1 - 32 bytes. Use 1 for minimum area, or 8 - 32 for
  maximum throughput.


LEON3 interrupt controller
CONFIG_IRQ3_ENABLE
  Say Y here to enable the LEON3 interrupt controller. This is needed
  if you want to be able to receive interrupts. Operating systems like
  Linux, RTEMS and eCos needs this option to be enabled. If you intend
  to use the Bare-C run-time and not use interrupts, you could disable
  the interrupt controller and save about 500 gates.

LEON3 interrupt controller broadcast
CONFIG_IRQ3_BROADCAST_ENABLE
  If enabled the broadcast register is used to determine which
  interrupt should be sent to all cpus instead of just the first
  one that consumes it.

Secondary interrupts
CONFIG_IRQ3_SEC
  The interrupt controller handles 15 interrupts by default (1 - 15).
  These correspond to the 15 SPARC asyncronous traps (0x11 - 0x1F),
  and AMBA interrupts 1 - 15. This option will enable 16 additional
  (secondary) interrupts, corresponding to AMBA interrupts 16 - 31.
  The secondary interrupts will be multiplexed onto one of the first
  15 interrupts. The total number of handled interrupts can then
  be up to 30 (14 primary and 16 secondary).

Number of interrupts
CONFIG_IRQ3_NSEC
  Defines which of the first 15 interrupts should be used for the
  secondary (16 - 31) interrupts. Interrupt 15 should be avoided
  since it is not maskable by the processor.
Timer module enable
CONFIG_GPT_ENABLE
  Say Y here to enable the Modular Timer Unit. The timer unit consists
  of one common scaler and up to 7 independent timers. The timer unit
  is needed for Linux, RTEMS, eCos and the Bare-C run-times.

Timer module enable
CONFIG_GPT_NTIM
  Set the number of timers in the timer unit (1 - 7).

Scaler width
CONFIG_GPT_SW
  Set the width if the common pre-scaler (2 - 16 bits). The scaler
  is used to divide the system clock down to 1 MHz, so 8 bits should
  be sufficient for most implementations (allows clocks up to 256 MHz).

Timer width
CONFIG_GPT_TW
  Set the width if the timers (2 - 32 bits). 32 bits is recommended
  for the Bare-C run-time, lower values (e.g. 16 bits) can work with
  RTEMS and Linux.

Timer Interrupt
CONFIG_GPT_IRQ
  Set the interrupt number for the first timer. Remaining timers will
  have incrementing interrupts, unless the separate-interrupts option
  below is disabled.

Watchdog enable
CONFIG_GPT_WDOGEN
  Say Y here to enable the watchdog functionality in the timer unit.

Watchdog time-out value
CONFIG_GPT_WDOG
  This value will be loaded in the watchdog timer at reset.

GPIO port
CONFIG_GRGPIO_ENABLE
  Say Y here to enable a general purpose I/O port. The port can be
  configured from 1 - 32 bits, whith each port signal individually
  programmable as input or output. The port signals can also serve
  as interrupt inputs.

GPIO port witdth
CONFIG_GRGPIO_WIDTH
  Number of bits in the I/O port. Must be in the range of 1 - 32.

GPIO interrupt mask
CONFIG_GRGPIO_IMASK
  The I/O port interrupt mask defines which bits in the I/O port
  should be able to create an interrupt. 

OpenCores I2C Master 
CONFIG_I2C_ENABLE
  Say Y here to enable the OpenCores I2C master.
Text-mode VGA
CONFIG_VGA_ENABLE
  Say Y here to enable a simple text-mode VGA controller. The controller
  generate 48x36 characters on a 640x480 pixel screen. The pixel clock
  is 25 MHz.

SVGA frame buffer
CONFIG_SVGA_ENABLE
  Say Y here to enable a graphical frame buffer. The frame buffer
  can be configured up to 1024x768 pixels and 8-, 16- or 32-bit 
  colour depth. 

PS2 KBD interface
CONFIG_KBD_ENABLE
  Say Y here to enable a PS/2 keyboard or mouse interface.

SPI memory controller
CONFIG_SPIMCTRL
  Say Y here to enable a simple SPI memory controller.
  The controller maps a SPI memory device into AMBA address space and
  also has a simple interface that allows sending commands directly
  to the SPI device.

Read command
CONFIG_SPIMCTRL_READCMD
  Read instruction for SPI memory device (hex).

Dummy byte
CONFIG_SPIMCTRL_DUMMYBYTE
  Output dummy byte after address when issuing read instruction.

Dual output
CONFIG_SPIMCTRL_DUALOUTPUT
  Memory device supports dual output when reading data.

Address offset
CONFIG_SPIMCTRL_OFFSET
  Offset that will be added by core on SPI memory address (hex).

Clock scaler
CONFIG_SPIMCTRL_SCALER
  Selects the divisor used when dividing the system clock to produce
  the memory device clock. The divisor used is two to the power of the
  specified value. This value must be at least 1.

Alternate clock scaler
CONFIG_SPIMCTRL_ASCALER
  Selects the divisor used when dividing the system clock to produce 
  the alternate memory device clock. If the selected memory device is 
  a SD Card this clock will be used during card initialization. The
  divisor used is two to the power of the specified value. This
  value must be at least 1.

Power-up cnt
CONFIG_SPIMCTRL_PWRUPCNT
  Number of system clock cycles to wait before issuing first command.
Gaisler Research SPI controller
CONFIG_SPICTRL_ENABLE
  Say Y here to enable the SPI controller(s)

CONFIG_SPICTRL_NUM
  Number of SPI controllers to implement in design. Note that most
  template designs are limited to one SPI controller.
  Configuration options made here in xconfig will apply to all
  implemented SPI controllers.

CONFIG_SPICTRL_MAXWLEN
  0: Core will support lengths up to 32 bits
  1-2: Illegal values
  3-15: Maximum word length will be value+1 (4-16)

CONFIG_SPICTRL_SYNCRAM
  Say Y here to use SYNCRAM_2P components for the core's receive
  and transmit queues. This is the recommended setting, particularly
  if the core is implemented with support for automatic mode.

CONFIG_SPICTRL_FT
  Fault-tolerance for internal buffers. Only applicable if core
  buffers are implemented with SYNCRAM components.

Dynamic Partial Reconfiguration
CONFIG_PARTIAL
	Say Y here to enable Partial Reconfiguration (only for Xilinx Devices).
	
Bitstream Verification
CONFIG_CRC
	Say Y to enable bitstream verification (CRC) (i.e., DPRC works in D2PRC-CRC mode).

Bitstream Error Detection and Correction
CONFIG_EDAC
	Say Y to enable bitstream EDAC (i.e., DPRC works in D2PRC-SECDED mode).

CRC Block Size
CONFIG_BLOCK
	Number of 32-bit words in a CRC block. Valid range 2 to 496. This value must not be greater than FIFO depth-16
	
Instantiate DCM and FIFO buffers
CONFIG_DCM_FIFO
	Say Y(N) to setup DPRC in Async(Sync) mode. If AHB/APB bus frequency is lower than 100 MHz, and if bitstream verification is disabled, DPRC can be setup to work in Sync mode.

Configure the depth of the FIFO buffer
CONFIG_DPR_FIFO64
	Valid for Async and D2PRC modes only. Set the depth of the FIFO buffer.



UART debugging
CONFIG_DEBUG_UART
  During simulation, the output from the UARTs is printed on the
  simulator console. Since the ratio between the system clock and
  UART baud-rate is quite high, simulating UART output will be very
  slow. If you say Y here, the UARTs will print a character as soon
  as it is stored in the transmitter data register. The transmitter
  ready flag will be permanently set, speeding up simulation. However,
  the output on the UART tx line will be garbled.  Has not impact on
  synthesis, but will cause the LEON test bench to fail.

FPU register tracing
CONFIG_DEBUG_FPURF
  If you say Y here, all writes to the floating-point unit register file
  will be printed on the simulator console.

