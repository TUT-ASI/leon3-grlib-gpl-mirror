----------------------------------------------------------------------------------------------
--
-- VHDL file generated by X-HDL - Revision 3.2.53  Aug. 1, 2005
-- Tue Aug  9 07:33:51 2005
--
--      Input file         : C:/Documents and Settings/BryantI/My Documents/tmp/can_top.v
--      Design name        : can_btl_core_sync
--      Author             :
--      Company            : Actel
--
--      Description        :
--
--
----------------------------------------------------------------------------------------------
--
--////////////////////////////////////////////////////////////////////
--//                                                              ////
--//  can_btl_core_sync.v                                              ////
--//                                                              ////
--//                                                              ////
--//  This file is part of the CAN Protocol Controller            ////
--//  http://www.opencores.org/projects/can/                      ////
--//                                                              ////
--//                                                              ////
--//  Author(s):                                                  ////
--//       Igor Mohor                                             ////
--//       igorm@opencores.org                                    ////
--//                                                              ////
--//                                                              ////
--//  All additional information is available in the README.txt   ////
--//  file.                                                       ////
--//                                                              ////
--////////////////////////////////////////////////////////////////////
--//                                                              ////
--// Copyright (C) 2002, 2003, 2004 Authors                       ////
--//                                                              ////
--// This source file may be used and distributed without         ////
--// restriction provided that this copyright statement is not    ////
--// removed from the file and that any derivative work contains  ////
--// the original copyright notice and the associated disclaimer. ////
--//                                                              ////
--// This source file is free software; you can redistribute it   ////
--// and/or modify it under the terms of the GNU Lesser General   ////
--// Public License as published by the Free Software Foundation; ////
--// either version 2.1 of the License, or (at your option) any   ////
--// later version.                                               ////
--//                                                              ////
--// This source is distributed in the hope that it will be       ////
--// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
--// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
--// PURPOSE.  See the GNU Lesser General Public License for more ////
--// details.                                                     ////
--//                                                              ////
--// You should have received a copy of the GNU Lesser General    ////
--// Public License along with this source; if not, download it   ////
--// from http://www.opencores.org/lgpl.shtml                     ////
--//                                                              ////
--// The CAN protocol is developed by Robert Bosch GmbH and       ////
--// protected by patents. Anybody who wants to implement this    ////
--// CAN IP core on silicon has to obtain a CAN protocol license  ////
--// from Bosch.                                                  ////
--//                                                              ////
--////////////////////////////////////////////////////////////////////
--
-- CVS Revision History
--
-- $Log: can_btl_core_sync.v,v $
-- Revision 1.30  2004/10/27 18:51:37  igorm
-- Fixed synchronization problem in real hardware when 0xf is used for TSEG1.
--
-- Revision 1.29  2004/05/12 15:58:41  igorm
-- Core improved to pass all tests with the Bosch VHDL Reference system.
--
-- Revision 1.28  2004/02/08 14:25:26  mohor
-- Header changed.
--
-- Revision 1.27  2003/09/30 00:55:13  mohor
-- Error counters fixed to be compatible with Bosch VHDL reference model.
-- Small synchronization changes.
--
-- Revision 1.26  2003/09/25 18:55:49  mohor
-- Synchronization changed, error counters fixed.
--
-- Revision 1.25  2003/07/16 13:40:35  mohor
-- Fixed according to the linter.
--
-- Revision 1.24  2003/07/10 15:32:28  mohor
-- Unused signal removed.
--
-- Revision 1.23  2003/07/10 01:59:04  tadejm
-- Synchronization fixed. In some strange cases it didn't work according to
-- the VHDL reference model.
--
-- Revision 1.22  2003/07/07 11:21:37  mohor
-- Little fixes (to fix warnings).
--
-- Revision 1.21  2003/07/03 09:32:20  mohor
-- Synchronization changed.
--
-- Revision 1.20  2003/06/20 14:51:11  mohor
-- Previous change removed. When resynchronization occurs we go to seg1
-- stage. sync stage does not cause another start of seg1 stage.
--
-- Revision 1.19  2003/06/20 14:28:20  mohor
-- When hard_sync or resync occure we need to go to seg1 segment. Going to
-- sync segment is in that case blocked.
--
-- Revision 1.18  2003/06/17 15:53:33  mohor
-- clk_cnt reduced from [8:0] to [6:0].
--
-- Revision 1.17  2003/06/17 14:32:17  mohor
-- Removed few signals.
--
-- Revision 1.16  2003/06/16 13:57:58  mohor
-- tx_point generated one clk earlier. rx_i registered. Data corrected when
-- using extended mode.
--
-- Revision 1.15  2003/06/13 15:02:24  mohor
-- Synchronization is also needed when transmitting a message.
--
-- Revision 1.14  2003/06/13 14:55:11  mohor
-- Counters width changed.
--
-- Revision 1.13  2003/06/11 14:21:35  mohor
-- When switching to tx, sync stage is overjumped.
--
-- Revision 1.12  2003/02/14 20:17:01  mohor
-- Several registers added. Not finished, yet.
--
-- Revision 1.11  2003/02/09 18:40:29  mohor
-- Overload fixed. Hard synchronization also enabled at the last bit of
-- interframe.
--
-- Revision 1.10  2003/02/09 02:24:33  mohor
-- Bosch license warning added. Error counters finished. Overload frames
-- still need to be fixed.
--
-- Revision 1.9  2003/01/31 01:13:38  mohor
-- backup.
--
-- Revision 1.8  2003/01/10 17:51:34  mohor
-- Temporary version (backup).
--
-- Revision 1.7  2003/01/08 02:10:53  mohor
-- Acceptance filter added.
--
-- Revision 1.6  2002/12/28 04:13:23  mohor
-- Backup version.
--
-- Revision 1.5  2002/12/27 00:12:52  mohor
-- Header changed, testbench improved to send a frame (crc still missing).
--
-- Revision 1.4  2002/12/26 01:33:05  mohor
-- Tripple sampling supported.
--
-- Revision 1.3  2002/12/25 23:44:16  mohor
-- Commented lines removed.
--
-- Revision 1.2  2002/12/25 14:17:00  mohor
-- Synchronization working.
--
-- Revision 1.1.1.1  2002/12/20 16:39:21  mohor
-- Initial
--
--
--
-- synopsys translate_off
--`include "can_defines.v"
-- synopsys translate_on

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

library grlib;
use grlib.stdlib.all;

ENTITY can_btl_core_sync IS
   PORT (
      clk                     : IN std_logic;
      rst                     : IN std_logic;
      rx                      : IN std_logic;
      tx                      : IN std_logic;
      -- Bus Timing 0 register
      baud_r_presc            : IN std_logic_vector(10 DOWNTO 0); --##
      sync_jump_width         : IN std_logic_vector(1 DOWNTO 0);
      -- Bus Timing 1 register
      time_segment1           : IN std_logic_vector(3 DOWNTO 0);
      time_segment2           : IN std_logic_vector(2 DOWNTO 0);
      triple_sampling         : IN std_logic;
      -- Output signals from this module
      sample_point            : OUT std_logic;
      sampled_bit             : OUT std_logic;
      sampled_bit_q           : OUT std_logic;
      tx_point                : OUT std_logic;
      hard_sync               : OUT std_logic;
      -- Output from can_bsp_core_sync module
      rx_idle                 : IN std_logic;
      rx_inter                : IN std_logic;
      transmitting            : IN std_logic;
      transmitter             : IN std_logic;
      go_rx_inter             : IN std_logic;
      tx_next                 : IN std_logic;
      go_overload_frame       : IN std_logic;
      go_error_frame          : IN std_logic;
      go_tx                   : IN std_logic;
      send_ack                : IN std_logic;
      node_error_passive      : IN std_logic);
END ENTITY can_btl_core_sync;

ARCHITECTURE RTL OF can_btl_core_sync IS

   TYPE xhdl_46 IS ARRAY (0 TO 7) OF std_logic_vector(7 DOWNTO 0);

   SIGNAL clk_cnt                  :  std_logic_vector(10 DOWNTO 0); --##
   SIGNAL clk_en                   :  std_logic;
   SIGNAL clk_en_q                 :  std_logic;
   SIGNAL sync_blocked             :  std_logic;
   SIGNAL hard_sync_blocked        :  std_logic;
   SIGNAL quant_cnt                :  std_logic_vector(4 DOWNTO 0);
   SIGNAL delay                    :  std_logic_vector(3 DOWNTO 0);
   SIGNAL sync                     :  std_logic;
   SIGNAL seg1                     :  std_logic;
   SIGNAL seg2                     :  std_logic;
   SIGNAL resync_latched           :  std_logic;
   SIGNAL sample                   :  std_logic_vector(1 DOWNTO 0);
   SIGNAL tx_next_sp               :  std_logic;
   SIGNAL go_sync                  :  std_logic;
   SIGNAL go_seg1                  :  std_logic;
   SIGNAL go_seg2                  :  std_logic;
   SIGNAL preset_cnt               :  std_logic_vector(10 DOWNTO 0); --##
   SIGNAL sync_window              :  std_logic;
   SIGNAL resync                   :  std_logic;
   -- when transmitting 0 with positive error delay is set to 0
   SIGNAL temp_xhdl6               :  std_logic_vector(4 DOWNTO 0);
   SIGNAL sample_point_xhdl1       :  std_logic;
   SIGNAL sampled_bit_xhdl2        :  std_logic;
   SIGNAL sampled_bit_q_xhdl3      :  std_logic;
   SIGNAL tx_point_xhdl4           :  std_logic;
   SIGNAL hard_sync_xhdl5          :  std_logic;

   signal time_segment1_ext, delay_ext, add_ext: std_logic_vector(4 DOWNTO 0); --##

BEGIN
   sample_point <= sample_point_xhdl1;
   sampled_bit <= sampled_bit_xhdl2;
   sampled_bit_q <= sampled_bit_q_xhdl3;
   tx_point <= tx_point_xhdl4;
   hard_sync <= hard_sync_xhdl5;
--   preset_cnt <=  (('0' & baud_r_presc) + 1) & "0" ;
--##   preset_cnt <=  "00" & baud_r_presc + '1';
   preset_cnt <=  baud_r_presc; --##                     --## extend scaler

   hard_sync_xhdl5 <= (((rx_idle OR rx_inter) AND (NOT rx)) AND sampled_bit_xhdl2) AND (NOT hard_sync_blocked) ;
   resync <= ((((NOT rx_idle) AND (NOT rx_inter)) AND (NOT rx)) AND sampled_bit_xhdl2) AND (NOT sync_blocked) ;

   -- Generating general enable signal that defines baud rate.
   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         clk_cnt <= "0000000";
      IF (clk'EVENT AND clk = '1') THEN
         IF (rst = '1') THEN
            clk_cnt <= (others => '0'); --##
         ELSIF (clk_cnt >= preset_cnt) then --##
            clk_cnt <= (others => '0'); --##
         ELSE
            clk_cnt <= clk_cnt + '1' ; --##
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         clk_en <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (rst = '1') THEN
            clk_en <= '0';
         ELSIF (clk_cnt = preset_cnt) then --##
            clk_en <= '1' ;
         ELSE
            clk_en <= '0' ;
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         clk_en_q <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (rst = '1') THEN
            clk_en_q <= '0';
	 ELSE
            clk_en_q <= clk_en ;
         END IF;
      END IF;
   END PROCESS;
   -- Changing states
   go_sync <= (((clk_en_q AND seg2) AND CONV_STD_LOGIC(quant_cnt(2 DOWNTO 0) = time_segment2)) AND (NOT hard_sync_xhdl5)) AND (NOT resync) ;
   go_seg1 <= clk_en_q AND (sync OR hard_sync_xhdl5 OR ((resync AND seg2) AND sync_window) OR (resync_latched AND sync_window)) ;

   time_segment1_ext <=  '0' & time_segment1;   --## fix comparison for max values
   delay_ext <=  '0' & delay;                   --##
   add_ext <= time_segment1_ext + delay_ext;    --##

   go_seg2 <= clk_en_q AND ((seg1 AND (NOT hard_sync_xhdl5)) AND CONV_STD_LOGIC(quant_cnt = add_ext)) ;--##
--##   go_seg2 <= clk_en_q AND ((seg1 AND (NOT hard_sync_xhdl5)) AND CONV_STD_LOGIC(quant_cnt = ( '0' & (time_segment1 + delay)))) ;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         tx_point_xhdl4 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         tx_point_xhdl4 <= (NOT tx_point_xhdl4 AND seg2) AND ((clk_en AND CONV_STD_LOGIC(quant_cnt(2 DOWNTO 0) = time_segment2)) OR ((clk_en OR clk_en_q) AND (resync OR hard_sync_xhdl5))) ;    --  When transmitter we should transmit as soon as possible.
        IF (rst = '1') THEN
           tx_point_xhdl4 <= '0';
        END IF;
      END IF;
   END PROCESS;

   -- When early edge is detected outside of the SJW field, synchronization request is latched and performed when
   --  When early edge is detected outside of the SJW field, synchronization request is latched and performed when
   --    SJW is reached

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         resync_latched <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (((resync AND seg2) AND (NOT sync_window)) = '1') THEN
            resync_latched <= '1' ;
         ELSE
            IF (go_seg1 = '1') THEN
               resync_latched <= '0';
            END IF;
         END IF;
         IF (rst = '1') THEN
            resync_latched <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Synchronization stage/segment
   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         sync <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (clk_en_q = '1') THEN
            sync <= go_sync ;
         END IF;
         IF (rst = '1') THEN
           sync <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Seg1 stage/segment (together with propagation segment which is 1 quant long)
   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         seg1 <= '1';
      IF (clk'EVENT AND clk = '1') THEN
         IF (go_seg1 = '1') THEN
            seg1 <= '1' ;
         ELSE
            IF (go_seg2 = '1') THEN
               seg1 <= '0' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            seg1 <= '1';
         END IF;
      END IF;
   END PROCESS;

   -- Seg2 stage/segment
   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         seg2 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (go_seg2 = '1') THEN
            seg2 <= '1' ;
         ELSE
            IF ((go_sync OR go_seg1) = '1') THEN
               seg2 <= '0' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            seg2 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Quant counter
   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         quant_cnt <= "00000";
      IF (clk'EVENT AND clk = '1') THEN
         IF ((go_sync OR go_seg1 OR go_seg2) = '1') THEN
            quant_cnt <= "00000" ;
         ELSE
            IF (clk_en_q = '1') THEN
               quant_cnt <= quant_cnt + "00001" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            quant_cnt <= "00000";
         END IF;
      END IF;
   END PROCESS;
   temp_xhdl6 <= ("0" & ("00" & sync_jump_width + "0001")) WHEN (quant_cnt > "000" & sync_jump_width) ELSE (quant_cnt + "00001");

   -- When late edge is detected (in seg1 stage), stage seg1 is prolonged.
   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         delay <= "0000";
      IF (clk'EVENT AND clk = '1') THEN
         IF (((resync AND seg1) AND (NOT transmitting OR (transmitting AND (tx_next_sp OR (tx AND (NOT rx)))))) = '1') THEN
            delay <= temp_xhdl6(3 DOWNTO 0) ;
         ELSE
            IF ((go_sync OR go_seg1) = '1') THEN
               delay <= "0000" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            delay <= "0000";
         END IF;
      END IF;
   END PROCESS;
   -- If early edge appears within this window (in seg2 stage), phase error is fully compensated
   sync_window <= CONV_STD_LOGIC((time_segment2 - quant_cnt(2 DOWNTO 0)) < ('0' & (sync_jump_width + "01"))) ;

   -- Sampling data (memorizing two samples all the time).

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         sample <= "11";
      IF (clk'EVENT AND clk = '1') THEN
         IF (clk_en_q = '1') THEN
            sample <= sample(0) & rx;
         END IF;
         IF (rst = '1') THEN
            sample <= "11";
         END IF;
      END IF;
   END PROCESS;

   -- When enabled, tripple sampling is done here.

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         sampled_bit_xhdl2 <= '1';
--         sampled_bit_q_xhdl3 <= '1';
--         sample_point_xhdl1 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (go_error_frame = '1') THEN
            sampled_bit_q_xhdl3 <= sampled_bit_xhdl2 ;
            sample_point_xhdl1 <= '0' ;
         ELSE
            IF ((clk_en_q AND (NOT hard_sync_xhdl5)) = '1') THEN
--##               IF ((seg1 AND CONV_STD_LOGIC(quant_cnt = ('0' & (time_segment1 + delay)))) = '1') THEN
               IF ((seg1 AND CONV_STD_LOGIC(quant_cnt = add_ext )) = '1') then --##
                  sample_point_xhdl1 <= '1' ;
                  sampled_bit_q_xhdl3 <= sampled_bit_xhdl2 ;
                  IF (triple_sampling = '1') THEN
                     sampled_bit_xhdl2 <= (sample(0) AND sample(1)) OR (sample(0) AND rx) OR (sample(1) AND rx) ;
                  ELSE
                     sampled_bit_xhdl2 <= rx ;
                  END IF;
-- kc fix
               ELSE
                 sample_point_xhdl1 <= '0' ;
--
               END IF;
            ELSE
               sample_point_xhdl1 <= '0' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            sampled_bit_xhdl2 <= '1';
            sampled_bit_q_xhdl3 <= '1';
            sample_point_xhdl1 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- tx_next_sp shows next value that will be driven on the TX. When driving 1 and receiving 0 we
   -- need to synchronize (even when we are a transmitter)

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         tx_next_sp <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((go_overload_frame OR (go_error_frame AND (NOT node_error_passive)) OR go_tx OR send_ack) = '1') THEN
            tx_next_sp <= '0' ;
         ELSE
            IF ((go_error_frame AND node_error_passive) = '1') THEN
               tx_next_sp <= '1' ;
            ELSE
               IF (sample_point_xhdl1 = '1') THEN
                  tx_next_sp <= tx_next ;
               END IF;
            END IF;
         END IF;
         IF (rst = '1') THEN
            tx_next_sp <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Blocking synchronization (can occur only once in a bit time)
   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         sync_blocked <= '1' ;
      IF (clk'EVENT AND clk = '1') THEN
         IF (clk_en_q = '1') THEN
            IF (resync = '1') THEN
               sync_blocked <= '1' ;
            ELSE
               IF (go_seg2 = '1') THEN
                  sync_blocked <= '0' ;
               END IF;
            END IF;
         END IF;
         IF (rst = '1') THEN
            sync_blocked <= '1' ;
         END IF;
      END IF;
   END PROCESS;

   -- Blocking hard synchronization when occurs once or when we are transmitting a msg
   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         hard_sync_blocked <= '0' ;
      IF (clk'EVENT AND clk = '1') THEN
         IF (((hard_sync_xhdl5 AND clk_en_q) OR ((((transmitting AND transmitter) OR go_tx) AND tx_point_xhdl4) AND (NOT tx_next))) = '1') THEN
            hard_sync_blocked <= '1' ;
         ELSE
            IF ((go_rx_inter OR (((rx_idle OR rx_inter) AND sample_point_xhdl1) AND sampled_bit_xhdl2)) = '1') THEN
               -- When a glitch performed synchronization

               hard_sync_blocked <= '0' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            hard_sync_blocked <= '0' ;
         END IF;
      END IF;
   END PROCESS;

END ARCHITECTURE RTL;

----------------------------------------------------------------------------------------------
--
-- VHDL file generated by X-HDL - Revision 3.2.53  Aug. 1, 2005
-- Tue Aug  9 07:33:51 2005
--
--      Input file         : C:/Documents and Settings/BryantI/My Documents/tmp/can_top.v
--      Design name        : can_crc_core_sync
--      Author             :
--      Company            : Actel
--
--      Description        :
--
--
----------------------------------------------------------------------------------------------
--
--////////////////////////////////////////////////////////////////////
--//                                                              ////
--//  can_crc_core_sync.v                                                   ////
--//                                                              ////
--//                                                              ////
--//  This file is part of the CAN Protocol Controller            ////
--//  http://www.opencores.org/projects/can/                      ////
--//                                                              ////
--//                                                              ////
--//  Author(s):                                                  ////
--//       Igor Mohor                                             ////
--//       igorm@opencores.org                                    ////
--//                                                              ////
--//                                                              ////
--//  All additional information is available in the README.txt   ////
--//  file.                                                       ////
--//                                                              ////
--////////////////////////////////////////////////////////////////////
--//                                                              ////
--// Copyright (C) 2002, 2003, 2004 Authors                       ////
--//                                                              ////
--// This source file may be used and distributed without         ////
--// restriction provided that this copyright statement is not    ////
--// removed from the file and that any derivative work contains  ////
--// the original copyright notice and the associated disclaimer. ////
--//                                                              ////
--// This source file is free software; you can redistribute it   ////
--// and/or modify it under the terms of the GNU Lesser General   ////
--// Public License as published by the Free Software Foundation; ////
--// either version 2.1 of the License, or (at your option) any   ////
--// later version.                                               ////
--//                                                              ////
--// This source is distributed in the hope that it will be       ////
--// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
--// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
--// PURPOSE.  See the GNU Lesser General Public License for more ////
--// details.                                                     ////
--//                                                              ////
--// You should have received a copy of the GNU Lesser General    ////
--// Public License along with this source; if not, download it   ////
--// from http://www.opencores.org/lgpl.shtml                     ////
--//                                                              ////
--// The CAN protocol is developed by Robert Bosch GmbH and       ////
--// protected by patents. Anybody who wants to implement this    ////
--// CAN IP core on silicon has to obtain a CAN protocol license  ////
--// from Bosch.                                                  ////
--//                                                              ////
--////////////////////////////////////////////////////////////////////
--
-- CVS Revision History
--
-- $Log: can_crc_core_sync.v,v $
-- Revision 1.5  2004/02/08 14:25:57  mohor
-- Header changed.
--
-- Revision 1.4  2003/07/16 13:16:51  mohor
-- Fixed according to the linter.
--
-- Revision 1.3  2003/02/10 16:02:11  mohor
-- CAN is working according to the specification. WB interface and more
-- registers (status, IRQ, ...) needs to be added.
--
-- Revision 1.2  2003/02/09 02:24:33  mohor
-- Bosch license warning added. Error counters finished. Overload frames
-- still need to be fixed.
--
-- Revision 1.1  2003/01/08 02:10:54  mohor
-- Acceptance filter added.
--
--
--
--
-- synopsys translate_off
--`include "can_defines.v"
-- synopsys translate_on

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

library grlib;
use grlib.stdlib.all;

ENTITY can_crc_core_sync IS
   PORT (
      clk                     : IN std_logic;
      data                    : IN std_logic;
      enable                  : IN std_logic;
      initialize              : IN std_logic;
      crc                     : OUT std_logic_vector(14 DOWNTO 0));
END ENTITY can_crc_core_sync;

ARCHITECTURE RTL OF can_crc_core_sync IS

   TYPE xhdl_46 IS ARRAY (0 TO 7) OF std_logic_vector(7 DOWNTO 0);

   SIGNAL crc_next                 :  std_logic;
   SIGNAL crc_tmp                  :  std_logic_vector(14 DOWNTO 0);
   SIGNAL crc_xhdl1                :  std_logic_vector(14 DOWNTO 0);

BEGIN
   crc <= crc_xhdl1;
   crc_next <= data XOR crc_xhdl1(14) ;
   crc_tmp <= crc_xhdl1(13 DOWNTO 0) & '0' ;

   PROCESS (clk)
   BEGIN
      IF (clk'EVENT AND clk = '1') THEN
         IF (initialize = '1') THEN
            crc_xhdl1 <= "000000000000000";
         ELSE
            IF (enable = '1') THEN
               IF (crc_next = '1') THEN
                  crc_xhdl1 <= crc_tmp XOR "100010110011001";
               ELSE
                  crc_xhdl1 <= crc_tmp ;
               END IF;
            END IF;
         END IF;
      END IF;
   END PROCESS;

END ARCHITECTURE RTL;
----------------------------------------------------------------------------------------------
--
-- VHDL file generated by X-HDL - Revision 3.2.53  Aug. 1, 2005
-- Tue Aug  9 07:33:51 2005
--
--      Input file         : C:/Documents and Settings/BryantI/My Documents/tmp/can_top.v
--      Design name        : can_ibo_core_sync
--      Author             :
--      Company            : Actel
--
--      Description        :
--
--
----------------------------------------------------------------------------------------------
--
--////////////////////////////////////////////////////////////////////
--//                                                              ////
--//  can_ibo_core_sync.v                                                   ////
--//                                                              ////
--//                                                              ////
--//  This file is part of the CAN Protocol Controller            ////
--//  http://www.opencores.org/projects/can/                      ////
--//                                                              ////
--//                                                              ////
--//  Author(s):                                                  ////
--//       Igor Mohor                                             ////
--//       igorm@opencores.org                                    ////
--//                                                              ////
--//                                                              ////
--//  All additional information is available in the README.txt   ////
--//  file.                                                       ////
--//                                                              ////
--////////////////////////////////////////////////////////////////////
--//                                                              ////
--// Copyright (C) 2002, 2003, 2004 Authors                       ////
--//                                                              ////
--// This source file may be used and distributed without         ////
--// restriction provided that this copyright statement is not    ////
--// removed from the file and that any derivative work contains  ////
--// the original copyright notice and the associated disclaimer. ////
--//                                                              ////
--// This source file is free software; you can redistribute it   ////
--// and/or modify it under the terms of the GNU Lesser General   ////
--// Public License as published by the Free Software Foundation; ////
--// either version 2.1 of the License, or (at your option) any   ////
--// later version.                                               ////
--//                                                              ////
--// This source is distributed in the hope that it will be       ////
--// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
--// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
--// PURPOSE.  See the GNU Lesser General Public License for more ////
--// details.                                                     ////
--//                                                              ////
--// You should have received a copy of the GNU Lesser General    ////
--// Public License along with this source; if not, download it   ////
--// from http://www.opencores.org/lgpl.shtml                     ////
--//                                                              ////
--// The CAN protocol is developed by Robert Bosch GmbH and       ////
--// protected by patents. Anybody who wants to implement this    ////
--// CAN IP core on silicon has to obtain a CAN protocol license  ////
--// from Bosch.                                                  ////
--//                                                              ////
--////////////////////////////////////////////////////////////////////
--
-- CVS Revision History
--
-- $Log: can_ibo_core_sync.v,v $
-- Revision 1.3  2004/02/08 14:31:44  mohor
-- Header changed.
--
-- Revision 1.2  2003/02/09 02:24:33  mohor
-- Bosch license warning added. Error counters finished. Overload frames
-- still need to be fixed.
--
-- Revision 1.1  2003/02/04 14:34:52  mohor
-- *** empty log message ***
--
--
--
--
-- synopsys translate_off
--`include "can_defines.v"
-- synopsys translate_on
-- This module only inverts bit order
LIBRARY ieee;
USE ieee.std_logic_1164.all;

library grlib;
use grlib.stdlib.all;

ENTITY can_ibo_core_sync IS
   PORT (
      di                      : IN std_logic_vector(7 DOWNTO 0);
      do                      : OUT std_logic_vector(7 DOWNTO 0));
END ENTITY can_ibo_core_sync;

ARCHITECTURE RTL OF can_ibo_core_sync IS

   TYPE xhdl_15 IS ARRAY (0 TO 63) OF std_logic_vector(7 DOWNTO 0);
   TYPE xhdl_16 IS ARRAY (0 TO 63) OF std_logic_vector(3 DOWNTO 0);
   TYPE xhdl_17 IS ARRAY (0 TO 63) OF std_logic;
   TYPE xhdl_46 IS ARRAY (0 TO 7) OF std_logic_vector(7 DOWNTO 0);

   SIGNAL do_xhdl1                 :  std_logic_vector(7 DOWNTO 0);

BEGIN
   do <= do_xhdl1;
   do_xhdl1(0) <= di(7) ;
   do_xhdl1(1) <= di(6) ;
   do_xhdl1(2) <= di(5) ;
   do_xhdl1(3) <= di(4) ;
   do_xhdl1(4) <= di(3) ;
   do_xhdl1(5) <= di(2) ;
   do_xhdl1(6) <= di(1) ;
   do_xhdl1(7) <= di(0) ;

END ARCHITECTURE RTL;
----------------------------------------------------------------------------------------------
--
-- VHDL file generated by X-HDL - Revision 3.2.53  Aug. 1, 2005
-- Tue Aug  9 07:33:51 2005
--
--      Input file         : C:/Documents and Settings/BryantI/My Documents/tmp/can_top.v
--      Design name        : can_bsp_core_sync
--      Author             :
--      Company            : Actel
--
--      Description        :
--
--
----------------------------------------------------------------------------------------------
--
--////////////////////////////////////////////////////////////////////
--//                                                              ////
--//  can_bsp_core_sync.v                                                   ////
--//                                                              ////
--//                                                              ////
--//  This file is part of the CAN Protocol Controller            ////
--//  http://www.opencores.org/projects/can/                      ////
--//                                                              ////
--//                                                              ////
--//  Author(s):                                                  ////
--//       Igor Mohor                                             ////
--//       igorm@opencores.org                                    ////
--//                                                              ////
--//                                                              ////
--//  All additional information is available in the README.txt   ////
--//  file.                                                       ////
--//                                                              ////
--////////////////////////////////////////////////////////////////////
--//                                                              ////
--// Copyright (C) 2002, 2003, 2004 Authors                       ////
--//                                                              ////
--// This source file may be used and distributed without         ////
--// restriction provided that this copyright statement is not    ////
--// removed from the file and that any derivative work contains  ////
--// the original copyright notice and the associated disclaimer. ////
--//                                                              ////
--// This source file is free software; you can redistribute it   ////
--// and/or modify it under the terms of the GNU Lesser General   ////
--// Public License as published by the Free Software Foundation; ////
--// either version 2.1 of the License, or (at your option) any   ////
--// later version.                                               ////
--//                                                              ////
--// This source is distributed in the hope that it will be       ////
--// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
--// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
--// PURPOSE.  See the GNU Lesser General Public License for more ////
--// details.                                                     ////
--//                                                              ////
--// You should have received a copy of the GNU Lesser General    ////
--// Public License along with this source; if not, download it   ////
--// from http://www.opencores.org/lgpl.shtml                     ////
--//                                                              ////
--// The CAN protocol is developed by Robert Bosch GmbH and       ////
--// protected by patents. Anybody who wants to implement this    ////
--// CAN IP core on silicon has to obtain a CAN protocol license  ////
--// from Bosch.                                                  ////
--//                                                              ////
--////////////////////////////////////////////////////////////////////
--
-- CVS Revision History
--
-- $Log: can_bsp_core_sync.v,v $
-- Revision 1.52  2004/11/18 12:39:21  igorm
-- Fixes for compatibility after the SW reset.
--
-- Revision 1.51  2004/11/15 18:23:21  igorm
-- When CAN was reset by setting the reset_mode signal in mode register, it
-- was possible that CAN was blocked for a short period of time. Problem
-- occured very rarly.
--
-- Revision 1.50  2004/10/27 18:51:36  igorm
-- Fixed synchronization problem in real hardware when 0xf is used for TSEG1.
--
-- Revision 1.49  2004/10/25 06:37:51  igorm
-- Arbitration bug fixed.
--
-- Revision 1.48  2004/05/12 15:58:41  igorm
-- Core improved to pass all tests with the Bosch VHDL Reference system.
--
-- Revision 1.47  2004/02/08 14:24:10  mohor
-- Error counters changed.
--
-- Revision 1.46  2003/10/17 05:55:20  markom
-- mbist signals updated according to newest convention
--
-- Revision 1.45  2003/09/30 21:14:33  mohor
-- Error counters changed.
--
-- Revision 1.44  2003/09/30 00:55:12  mohor
-- Error counters fixed to be compatible with Bosch VHDL reference model.
-- Small synchronization changes.
--
-- Revision 1.43  2003/09/25 18:55:49  mohor
-- Synchronization changed, error counters fixed.
--
-- Revision 1.42  2003/08/29 07:01:14  mohor
-- When detecting bus-free, signal bus_free_cnt_en was cleared to zero
-- although the last sampled bit was zero instead of one.
--
-- Revision 1.41  2003/07/18 15:23:31  tadejm
-- Tx and rx length are limited to 8 bytes regardless to the DLC value.
--
-- Revision 1.40  2003/07/16 15:10:17  mohor
-- Fixed according to the linter.
--
-- Revision 1.39  2003/07/16 13:12:46  mohor
-- Fixed according to the linter.
--
-- Revision 1.38  2003/07/10 01:59:04  tadejm
-- Synchronization fixed. In some strange cases it didn't work according to
-- the VHDL reference model.
--
-- Revision 1.37  2003/07/07 11:21:37  mohor
-- Little fixes (to fix warnings).
--
-- Revision 1.36  2003/07/03 09:32:20  mohor
-- Synchronization changed.
--
-- Revision 1.35  2003/06/27 20:56:12  simons
-- Virtual silicon ram instances added.
--
-- Revision 1.34  2003/06/22 09:43:03  mohor
-- synthesi full_case parallel_case fixed.
--
-- Revision 1.33  2003/06/21 12:16:30  mohor
-- paralel_case and full_case compiler directives added to case statements.
--
-- Revision 1.32  2003/06/17 14:28:32  mohor
-- Form error was detected when stuff bit occured at the end of crc.
--
-- Revision 1.31  2003/06/16 14:31:29  tadejm
-- Bit stuffing corrected when stuffing comes at the end of the crc.
--
-- Revision 1.30  2003/06/16 13:57:58  mohor
-- tx_point generated one clk earlier. rx_i registered. Data corrected when
-- using extended mode.
--
-- Revision 1.29  2003/06/11 14:21:35  mohor
-- When switching to tx, sync stage is overjumped.
--
-- Revision 1.28  2003/03/01 22:53:33  mohor
-- Actel APA ram supported.
--
-- Revision 1.27  2003/02/20 00:26:02  mohor
-- When a dominant bit was detected at the third bit of the intermission and
-- node had a message to transmit, bit_stuff error could occur. Fixed.
--
-- Revision 1.26  2003/02/19 23:21:54  mohor
-- When bit error occured while active error flag was transmitted, counter was
-- not incremented.
--
-- Revision 1.25  2003/02/19 14:44:03  mohor
-- CAN core finished. Host interface added. Registers finished.
-- Synchronization to the wishbone finished.
--
-- Revision 1.24  2003/02/18 00:10:15  mohor
-- Most of the registers added. Registers "arbitration lost capture", "error code
-- capture" + few more still need to be added.
--
-- Revision 1.23  2003/02/14 20:17:01  mohor
-- Several registers added. Not finished, yet.
--
-- Revision 1.22  2003/02/12 14:23:59  mohor
-- abort_tx added. Bit destuff fixed.
--
-- Revision 1.21  2003/02/11 00:56:06  mohor
-- Wishbone interface added.
--
-- Revision 1.20  2003/02/10 16:02:11  mohor
-- CAN is working according to the specification. WB interface and more
-- registers (status, IRQ, ...) needs to be added.
--
-- Revision 1.19  2003/02/09 18:40:29  mohor
-- Overload fixed. Hard synchronization also enabled at the last bit of
-- interframe.
--
-- Revision 1.18  2003/02/09 02:24:33  mohor
-- Bosch license warning added. Error counters finished. Overload frames
-- still need to be fixed.
--
-- Revision 1.17  2003/02/04 17:24:41  mohor
-- Backup.
--
-- Revision 1.16  2003/02/04 14:34:52  mohor
-- *** empty log message ***
--
-- Revision 1.15  2003/01/31 01:13:37  mohor
-- backup.
--
-- Revision 1.14  2003/01/16 13:36:19  mohor
-- Form error supported. When receiving messages, last bit of the end-of-frame
-- does not generate form error. Receiver goes to the idle mode one bit sooner.
-- (CAN specification ver 2.0, part B, page 57).
--
-- Revision 1.13  2003/01/15 21:59:45  mohor
-- Data is stored to fifo at the end of ack stage.
--
-- Revision 1.12  2003/01/15 21:05:11  mohor
-- CRC checking fixed (when bitstuff occurs at the end of a CRC sequence).
--
-- Revision 1.11  2003/01/15 14:40:23  mohor
-- RX state machine fixed to receive "remote request" frames correctly.
-- No data bytes are written to fifo when such frames are received.
--
-- Revision 1.10  2003/01/15 13:16:47  mohor
-- When a frame with "remote request" is received, no data is stored to
-- fifo, just the frame information (identifier, ...). Data length that
-- is stored is the received data length and not the actual data length
-- that is stored to fifo.
--
-- Revision 1.9  2003/01/14 12:19:35  mohor
-- rx_fifo is now working.
--
-- Revision 1.8  2003/01/10 17:51:33  mohor
-- Temporary version (backup).
--
-- Revision 1.7  2003/01/09 21:54:45  mohor
-- rx fifo added. Not 100 % verified, yet.
--
-- Revision 1.6  2003/01/09 14:46:58  mohor
-- Temporary files (backup).
--
-- Revision 1.5  2003/01/08 13:30:31  mohor
-- Temp version.
--
-- Revision 1.4  2003/01/08 02:10:53  mohor
-- Acceptance filter added.
--
-- Revision 1.3  2002/12/28 04:13:23  mohor
-- Backup version.
--
-- Revision 1.2  2002/12/27 00:12:52  mohor
-- Header changed, testbench improved to send a frame (crc still missing).
--
-- Revision 1.1.1.1  2002/12/20 16:39:21  mohor
-- Initial
--
--
--
-- synopsys translate_off
--`include "can_defines.v"
-- synopsys translate_on
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

library grlib;
use grlib.stdlib.all;

ENTITY can_bsp_core_sync IS
   PORT (
      clk                     : IN std_logic;
      rst                     : IN std_logic;
      restart                 : in std_logic;
      sample_point            : IN std_logic;
      sampled_bit             : IN std_logic;
      sampled_bit_q           : IN std_logic;
      tx_point                : IN std_logic;
      hard_sync               : IN std_logic;
      reset_mode              : IN std_logic;
      listen_only_mode        : IN std_logic;
      self_test_mode          : IN std_logic;
      -- Command register
      tx_request              : IN std_logic;
      abort_tx                : IN std_logic;
      self_rx_request         : IN std_logic;
      single_shot_transmission: IN std_logic;
      tx_state                : OUT std_logic;
      tx_state_q              : OUT std_logic;
      overload_request        : IN std_logic;   --  When receiver is busy, it needs to send overload frame. Only 2 overload frames are allowed to
      overload_frame          : OUT std_logic;   --  be send in a row. This is not implemented, yet,  because host can not send an overload request.
      -- Arbitration Lost Capture Register
      read_arbitration_lost_capture_reg: IN std_logic;
      -- Error Code Capture Register
      read_error_code_capture_reg: IN std_logic;
      error_capture_code      : OUT std_logic_vector(7 DOWNTO 0);
      -- Error Warning Limit register
      extended_mode           : IN std_logic;
      rx_idle                 : OUT std_logic;
      transmitting            : OUT std_logic;
      transmitter             : OUT std_logic;
      go_rx_inter             : OUT std_logic;
      not_first_bit_of_inter  : OUT std_logic;
      rx_inter                : OUT std_logic;
      node_bus_off            : OUT std_logic;
      rx_err_cnt              : OUT std_logic_vector(8 DOWNTO 0);
      tx_err_cnt              : OUT std_logic_vector(8 DOWNTO 0);
      transmit_status         : OUT std_logic;
      receive_status          : OUT std_logic;
      tx_successful           : OUT std_logic;
      need_to_tx              : OUT std_logic;
      overrun                 : OUT std_logic;
      set_bus_error_irq       : OUT std_logic;
      set_arbitration_lost_irq: OUT std_logic;
      arbitration_lost_capture: OUT std_logic_vector(4 DOWNTO 0);
      node_error_passive      : OUT std_logic;
      node_error_active       : OUT std_logic;


      tx_data_0               : IN std_logic_vector(7 DOWNTO 0);
      tx_data_1               : IN std_logic_vector(7 DOWNTO 0);
      tx_data_2               : IN std_logic_vector(7 DOWNTO 0);
      tx_data_3               : IN std_logic_vector(7 DOWNTO 0);
      tx_data_4               : IN std_logic_vector(7 DOWNTO 0);
      tx_data_5               : IN std_logic_vector(7 DOWNTO 0);
      tx_data_6               : IN std_logic_vector(7 DOWNTO 0);
      tx_data_7               : IN std_logic_vector(7 DOWNTO 0);
      tx_data_8               : IN std_logic_vector(7 DOWNTO 0);
      tx_data_9               : IN std_logic_vector(7 DOWNTO 0);
      tx_data_10              : IN std_logic_vector(7 DOWNTO 0);
      tx_data_11              : IN std_logic_vector(7 DOWNTO 0);
      tx_data_12              : IN std_logic_vector(7 DOWNTO 0);

      rcv_msg_data             : out std_logic_vector(63 downto 0);
      rcv_id                   : out std_logic_vector(28 downto 0);
      rcv_dlc                  : out std_logic_vector(3 downto 0);
      rcv_rtr                  : out std_logic;
      rcv_ide                  : out std_logic;
      rcv_msg_valid            : out std_logic;

      form_error               : out std_logic;
      crc_error                : out std_logic;
      ack_error                : out std_logic;
      stuff_error              : out std_logic;
      bit_error                : out std_logic;
      arb_loss                 : out std_logic;

      tx                      : OUT std_logic;
      tx_next                 : OUT std_logic;
      go_overload_frame       : OUT std_logic;
      go_error_frame          : OUT std_logic;
      go_tx                   : OUT std_logic;
      send_ack                : OUT std_logic);
END ENTITY can_bsp_core_sync;

ARCHITECTURE RTL OF can_bsp_core_sync IS


   COMPONENT can_crc_core_sync
      PORT (
         clk                     : IN  std_logic;
         data                    : IN  std_logic;
         enable                  : IN  std_logic;
         initialize              : IN  std_logic;
         crc                     : OUT std_logic_vector(14 DOWNTO 0));
   END COMPONENT;

   COMPONENT can_ibo_core_sync
      PORT (
         di                      : IN  std_logic_vector(7 DOWNTO 0);
         do                      : OUT std_logic_vector(7 DOWNTO 0));
   END COMPONENT;

   TYPE xhdl_46 IS ARRAY (0 TO 7) OF std_logic_vector(7 DOWNTO 0);

   ------------------------------

   SIGNAL reset_mode_q             :  std_logic;
   SIGNAL bit_cnt                  :  std_logic_vector(5 DOWNTO 0);
   SIGNAL data_len                 :  std_logic_vector(3 DOWNTO 0);
   SIGNAL id                       :  std_logic_vector(28 DOWNTO 0);
   SIGNAL bit_stuff_cnt            :  std_logic_vector(2 DOWNTO 0);
   SIGNAL bit_stuff_cnt_tx         :  std_logic_vector(2 DOWNTO 0);
   SIGNAL tx_point_q               :  std_logic;
   SIGNAL rx_id1                   :  std_logic;
   SIGNAL rx_rtr1                  :  std_logic;
   SIGNAL rx_ide                   :  std_logic;
   SIGNAL rx_id2                   :  std_logic;
   SIGNAL rx_rtr2                  :  std_logic;
   SIGNAL rx_r1                    :  std_logic;
   SIGNAL rx_r0                    :  std_logic;
   SIGNAL rx_dlc                   :  std_logic;
   SIGNAL rx_data                  :  std_logic;
   SIGNAL rx_crc                   :  std_logic;
   SIGNAL rx_crc_lim               :  std_logic;
   SIGNAL rx_ack                   :  std_logic;
   SIGNAL rx_ack_lim               :  std_logic;
   SIGNAL rx_eof                   :  std_logic;
   SIGNAL go_early_tx_latched      :  std_logic;
   SIGNAL rtr1                     :  std_logic;
   SIGNAL ide                      :  std_logic;
   SIGNAL rtr2                     :  std_logic;
   SIGNAL crc_in                   :  std_logic_vector(14 DOWNTO 0);
   SIGNAL tmp_data                 :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tmp_fifo                 :  xhdl_46;
   SIGNAL write_data_to_tmp_fifo   :  std_logic;
   SIGNAL byte_cnt                 :  std_logic_vector(2 DOWNTO 0);
   SIGNAL bit_stuff_cnt_en         :  std_logic;
   SIGNAL crc_enable               :  std_logic;
   SIGNAL eof_cnt                  :  std_logic_vector(2 DOWNTO 0);
   SIGNAL passive_cnt              :  std_logic_vector(2 DOWNTO 0);
   SIGNAL error_frame              :  std_logic;
   SIGNAL enable_error_cnt2        :  std_logic;
   SIGNAL error_cnt1               :  std_logic_vector(2 DOWNTO 0);
   SIGNAL error_cnt2               :  std_logic_vector(2 DOWNTO 0);
   SIGNAL delayed_dominant_cnt     :  std_logic_vector(2 DOWNTO 0);
   SIGNAL enable_overload_cnt2     :  std_logic;
   SIGNAL overload_frame_blocked   :  std_logic;
   SIGNAL overload_request_cnt     :  std_logic_vector(1 DOWNTO 0);
   SIGNAL overload_cnt1            :  std_logic_vector(2 DOWNTO 0);
   SIGNAL overload_cnt2            :  std_logic_vector(2 DOWNTO 0);
   SIGNAL crc_err                  :  std_logic;
   SIGNAL arbitration_lost         :  std_logic;
   SIGNAL arbitration_lost_q       :  std_logic;
   SIGNAL read_arbitration_lost_capture_reg_q:  std_logic;
   signal read_error_code_capture_reg_q : std_logic;
   signal reset_error_code_capture_reg : std_logic;
   SIGNAL arbitration_cnt_en       :  std_logic;
   SIGNAL arbitration_blocked      :  std_logic;
   SIGNAL tx_q                     :  std_logic;
   SIGNAL data_cnt                 :  std_logic_vector(3 DOWNTO 0);   --  Counting the data bytes that are written to FIFO
   SIGNAL header_cnt               :  std_logic_vector(2 DOWNTO 0);   --  Counting header length
   SIGNAL wr_fifo                  :  std_logic;   --  Write data and header to 64-byte fifo
   SIGNAL wr_fifo2                 :  std_logic;
   SIGNAL data_for_fifo            :  std_logic_vector(7 DOWNTO 0);   --  Multiplexed data that is stored to 64-byte fifo
   SIGNAL tx_pointer               :  std_logic_vector(5 DOWNTO 0);
   SIGNAL tx_bit                   :  std_logic;
   SIGNAL finish_msg               :  std_logic;
   SIGNAL bus_free_cnt             :  std_logic_vector(3 DOWNTO 0);
   SIGNAL bus_free_cnt_en          :  std_logic;
   SIGNAL bus_free                 :  std_logic;
   SIGNAL waiting_for_bus_free     :  std_logic;
   SIGNAL node_bus_off_q           :  std_logic;
   SIGNAL ack_err_latched          :  std_logic;
   SIGNAL bit_err_latched          :  std_logic;
   SIGNAL stuff_err_latched        :  std_logic;
   SIGNAL form_err_latched         :  std_logic;
   SIGNAL rule3_exc1_1             :  std_logic;
   SIGNAL rule3_exc1_2             :  std_logic;
   SIGNAL suspend                  :  std_logic;
   SIGNAL susp_cnt_en              :  std_logic;
   SIGNAL susp_cnt                 :  std_logic_vector(2 DOWNTO 0);
   SIGNAL error_flag_over_latched  :  std_logic;
   SIGNAL error_capture_code_type  :  std_logic_vector(7 DOWNTO 6);
   SIGNAL error_capture_code_blocked      :  std_logic;
   SIGNAL first_compare_bit        :  std_logic;
   SIGNAL error_capture_code_segment      :  std_logic_vector(4 DOWNTO 0);
   SIGNAL error_capture_code_direction    :  std_logic;
   SIGNAL bit_de_stuff             :  std_logic;
   SIGNAL bit_de_stuff_tx          :  std_logic;
   SIGNAL rule5                    :  std_logic;
   -- Rx state machine
   SIGNAL go_rx_idle               :  std_logic;
   SIGNAL go_rx_id1                :  std_logic;
   SIGNAL go_rx_rtr1               :  std_logic;
   SIGNAL go_rx_ide                :  std_logic;
   SIGNAL go_rx_id2                :  std_logic;
   SIGNAL go_rx_rtr2               :  std_logic;
   SIGNAL go_rx_r1                 :  std_logic;
   SIGNAL go_rx_r0                 :  std_logic;
   SIGNAL go_rx_dlc                :  std_logic;
   SIGNAL go_rx_data               :  std_logic;
   SIGNAL go_rx_crc                :  std_logic;
   SIGNAL go_rx_crc_lim            :  std_logic;
   SIGNAL go_rx_ack                :  std_logic;
   SIGNAL go_rx_ack_lim            :  std_logic;
   SIGNAL go_rx_eof                :  std_logic;
   SIGNAL last_bit_of_inter        :  std_logic;
   SIGNAL go_crc_enable            :  std_logic;
   SIGNAL rst_crc_enable           :  std_logic;
   SIGNAL bit_de_stuff_set         :  std_logic;
   SIGNAL bit_de_stuff_reset       :  std_logic;
   SIGNAL go_early_tx              :  std_logic;
   SIGNAL calculated_crc           :  std_logic_vector(14 DOWNTO 0);
   SIGNAL r_calculated_crc         :  std_logic_vector(15 DOWNTO 0);
   SIGNAL remote_rq                :  std_logic;
   SIGNAL limited_data_len         :  std_logic_vector(3 DOWNTO 0);
   SIGNAL form_err                 :  std_logic;
   SIGNAL error_frame_ended        :  std_logic;
   SIGNAL overload_frame_ended     :  std_logic;
   SIGNAL bit_err                  :  std_logic;
   SIGNAL ack_err                  :  std_logic;
   SIGNAL stuff_err                :  std_logic;
   SIGNAL id_ok                    :  std_logic;   --  If received ID matches ID set in registers
   SIGNAL no_byte0                 :  std_logic;   --  There is no byte 0 (RTR bit set to 1 or DLC field equal to 0). Signal used for acceptance filter.
   SIGNAL no_byte1                 :  std_logic;   --  There is no byte 1 (RTR bit set to 1 or DLC field equal to 1). Signal used for acceptance filter.
   SIGNAL header_len               :  std_logic_vector(2 DOWNTO 0);
   SIGNAL storing_header           :  std_logic;
   SIGNAL limited_data_len_minus1  :  std_logic_vector(3 DOWNTO 0);
   SIGNAL reset_wr_fifo            :  std_logic;
   SIGNAL err                      :  std_logic;
   SIGNAL arbitration_field        :  std_logic;
   SIGNAL basic_chain              :  std_logic_vector(18 DOWNTO 0);
   SIGNAL basic_chain_data         :  std_logic_vector(63 DOWNTO 0);
   SIGNAL extended_chain_std       :  std_logic_vector(18 DOWNTO 0);
   SIGNAL extended_chain_ext       :  std_logic_vector(38 DOWNTO 0);
   SIGNAL extended_chain_data_std  :  std_logic_vector(63 DOWNTO 0);
   SIGNAL extended_chain_data_ext  :  std_logic_vector(63 DOWNTO 0);
   SIGNAL rst_tx_pointer           :  std_logic;
   SIGNAL r_tx_data_0              :  std_logic_vector(7 DOWNTO 0);
   SIGNAL r_tx_data_1              :  std_logic_vector(7 DOWNTO 0);
   SIGNAL r_tx_data_2              :  std_logic_vector(7 DOWNTO 0);
   SIGNAL r_tx_data_3              :  std_logic_vector(7 DOWNTO 0);
   SIGNAL r_tx_data_4              :  std_logic_vector(7 DOWNTO 0);
   SIGNAL r_tx_data_5              :  std_logic_vector(7 DOWNTO 0);
   SIGNAL r_tx_data_6              :  std_logic_vector(7 DOWNTO 0);
   SIGNAL r_tx_data_7              :  std_logic_vector(7 DOWNTO 0);
   SIGNAL r_tx_data_8              :  std_logic_vector(7 DOWNTO 0);
   SIGNAL r_tx_data_9              :  std_logic_vector(7 DOWNTO 0);
   SIGNAL r_tx_data_10             :  std_logic_vector(7 DOWNTO 0);
   SIGNAL r_tx_data_11             :  std_logic_vector(7 DOWNTO 0);
   SIGNAL r_tx_data_12             :  std_logic_vector(7 DOWNTO 0);
   SIGNAL bit_err_exc1             :  std_logic;
   SIGNAL bit_err_exc2             :  std_logic;
   SIGNAL bit_err_exc3             :  std_logic;
   SIGNAL bit_err_exc4             :  std_logic;
   SIGNAL bit_err_exc5             :  std_logic;
   SIGNAL bit_err_exc6             :  std_logic;
   SIGNAL error_flag_over          :  std_logic;
   SIGNAL overload_flag_over       :  std_logic;
   SIGNAL limited_tx_cnt_ext       :  std_logic_vector(5 DOWNTO 0);
   SIGNAL limited_tx_cnt_std       :  std_logic_vector(5 DOWNTO 0);

   -- Instantiation of the RX CRC module
   SIGNAL xhdl_49                  :  std_logic;
   -- Mode register
   -- Clock Divider register
   -- This section is for BASIC and EXTENDED mode
   -- Acceptance code register
   -- Acceptance mask register
   -- End: This section is for BASIC and EXTENDED mode
   -- This section is for EXTENDED mode
   -- Acceptance code register
   -- Acceptance mask register
   -- End: This section is for EXTENDED mode

   SIGNAL temp_xhdl47              :  std_logic_vector(3 DOWNTO 0);
   SIGNAL port_xhdl73              :  std_logic_vector(7 DOWNTO 0);
   SIGNAL port_xhdl74              :  std_logic_vector(7 DOWNTO 0);
   SIGNAL temp_xhdl75              :  std_logic_vector(2 DOWNTO 0);
   SIGNAL temp_xhdl76              :  std_logic_vector(2 DOWNTO 0);
   SIGNAL temp_xhdl77              :  std_logic_vector(3 DOWNTO 0);
   SIGNAL temp_xhdl78              :  std_logic_vector(3 DOWNTO 0);   --  - 1 because counter counts from 0
   SIGNAL xhdl_106                 :  std_logic_vector(7 DOWNTO 0);
   SIGNAL temp_xhdl108             :  std_logic_vector(5 DOWNTO 0);
   SIGNAL temp_xhdl109             :  std_logic_vector(5 DOWNTO 0);
   SIGNAL temp_xhdl110             :  boolean;
   SIGNAL temp_xhdl111             :  std_logic;
   SIGNAL tx_state_xhdl2           :  std_logic;
   SIGNAL tx_state_q_xhdl3         :  std_logic;
   SIGNAL overload_frame_xhdl4     :  std_logic;
   SIGNAL error_capture_code_xhdl5 :  std_logic_vector(7 DOWNTO 0);
   SIGNAL rx_idle_xhdl6            :  std_logic;
   SIGNAL transmitting_xhdl7       :  std_logic;
   SIGNAL transmitter_xhdl8        :  std_logic;
   SIGNAL go_rx_inter_xhdl9        :  std_logic;
   SIGNAL not_first_bit_of_inter_xhdl10   :  std_logic;
   SIGNAL rx_inter_xhdl11          :  std_logic;
   SIGNAL node_bus_off_xhdl13      :  std_logic;
   SIGNAL rx_err_cnt_xhdl15        :  std_logic_vector(8 DOWNTO 0);
   SIGNAL tx_err_cnt_xhdl16        :  std_logic_vector(8 DOWNTO 0);
   SIGNAL transmit_status_xhdl17   :  std_logic;
   SIGNAL receive_status_xhdl18    :  std_logic;
   SIGNAL tx_successful_xhdl19     :  std_logic;
   SIGNAL need_to_tx_xhdl20        :  std_logic;
   SIGNAL overrun_xhdl21           :  std_logic;
   SIGNAL set_bus_error_irq_xhdl23 :  std_logic;
   SIGNAL set_arbitration_lost_irq_xhdl24 :  std_logic;
   SIGNAL arbitration_lost_capture_xhdl25 :  std_logic_vector(4 DOWNTO 0);
   SIGNAL node_error_passive_xhdl26:  std_logic;
   SIGNAL node_error_active_xhdl27 :  std_logic;
   SIGNAL tx_xhdl29                :  std_logic;
   SIGNAL tx_next_xhdl30           :  std_logic;
   SIGNAL go_overload_frame_xhdl32 :  std_logic;
   SIGNAL go_error_frame_xhdl33    :  std_logic;
   SIGNAL go_tx_xhdl34             :  std_logic;
   SIGNAL send_ack_xhdl35          :  std_logic;

   signal rx_msg_data : std_logic_vector(63 downto 0);

   SIGNAL set_reset_mode_xhdl12    :  std_logic;

BEGIN


   form_error       <= form_err_latched;
   crc_error        <= crc_err;
   ack_error        <= ack_err_latched;
   stuff_error      <= stuff_err_latched;
   bit_error        <= bit_err_latched;
   arb_loss         <= arbitration_lost;

   tx_state <= tx_state_xhdl2;
   tx_state_q <= tx_state_q_xhdl3;
   overload_frame <= overload_frame_xhdl4;
   error_capture_code <= error_capture_code_xhdl5;
   rx_idle <= rx_idle_xhdl6;
   transmitting <= transmitting_xhdl7;
   transmitter <= transmitter_xhdl8;
   go_rx_inter <= go_rx_inter_xhdl9;
   not_first_bit_of_inter <= not_first_bit_of_inter_xhdl10;
   rx_inter <= rx_inter_xhdl11;
   node_bus_off <= node_bus_off_xhdl13;
   rx_err_cnt <= rx_err_cnt_xhdl15;
   tx_err_cnt <= tx_err_cnt_xhdl16;
   transmit_status <= transmitter_xhdl8;
--   transmit_status <= transmit_status_xhdl17;
   receive_status <= receive_status_xhdl18;
   tx_successful <= tx_successful_xhdl19;
   need_to_tx <= need_to_tx_xhdl20;
   overrun <= overrun_xhdl21;
   set_bus_error_irq <= set_bus_error_irq_xhdl23;
   set_arbitration_lost_irq <= set_arbitration_lost_irq_xhdl24;
   arbitration_lost_capture <= arbitration_lost_capture_xhdl25;
   node_error_passive <= node_error_passive_xhdl26;
   node_error_active <= node_error_active_xhdl27;
   tx <= tx_xhdl29;
   tx_next <= tx_next_xhdl30;
   go_overload_frame <= go_overload_frame_xhdl32;
   go_error_frame <= go_error_frame_xhdl33;
   go_tx <= go_tx_xhdl34;
   send_ack <= send_ack_xhdl35;

   go_rx_idle <= ((sample_point AND sampled_bit) AND last_bit_of_inter) OR (bus_free AND (NOT node_bus_off_xhdl13)) ;
   go_rx_id1 <= (sample_point AND (NOT sampled_bit)) AND (rx_idle_xhdl6 OR last_bit_of_inter) ;
   go_rx_rtr1 <= (((NOT bit_de_stuff) AND sample_point) AND rx_id1) AND CONV_STD_LOGIC(bit_cnt(3 DOWNTO 0) = "1010") ;
   go_rx_ide <= ((NOT bit_de_stuff) AND sample_point) AND rx_rtr1 ;
   go_rx_id2 <= (((NOT bit_de_stuff) AND sample_point) AND rx_ide) AND sampled_bit ;
   go_rx_rtr2 <= (((NOT bit_de_stuff) AND sample_point) AND rx_id2) AND CONV_STD_LOGIC(bit_cnt(4 DOWNTO 0) = "10001") ;
   go_rx_r1 <= ((NOT bit_de_stuff) AND sample_point) AND rx_rtr2 ;
   go_rx_r0 <= ((NOT bit_de_stuff) AND sample_point) AND ((rx_ide AND (NOT sampled_bit)) OR rx_r1) ;
   go_rx_dlc <= ((NOT bit_de_stuff) AND sample_point) AND rx_r0 ;
   go_rx_data <= (((((NOT bit_de_stuff) AND sample_point) AND rx_dlc) AND CONV_STD_LOGIC(bit_cnt(1 DOWNTO 0) = "11")) AND (sampled_bit OR (orv(data_len(2 DOWNTO 0))))) AND (NOT remote_rq) ;
   go_rx_crc <= ((NOT bit_de_stuff) AND sample_point) AND (((rx_dlc AND CONV_STD_LOGIC(bit_cnt(1 DOWNTO 0) = "11")) AND (((NOT sampled_bit) AND (NOT (orv(data_len(2 DOWNTO 0))))) OR remote_rq)) OR (rx_data AND CONV_STD_LOGIC('0' & bit_cnt(5 DOWNTO 0) = ((limited_data_len & "000") - 1)))) ;
   go_rx_crc_lim <= (((NOT bit_de_stuff) AND sample_point) AND rx_crc) AND CONV_STD_LOGIC(bit_cnt(3 DOWNTO 0) = "1110") ;
   go_rx_ack <= ((NOT bit_de_stuff) AND sample_point) AND rx_crc_lim ;
   go_rx_ack_lim <= sample_point AND rx_ack ;
   go_rx_eof <= sample_point AND rx_ack_lim ;
   go_rx_inter_xhdl9 <= (((sample_point AND rx_eof) AND CONV_STD_LOGIC(eof_cnt = "110")) OR error_frame_ended OR overload_frame_ended) AND (NOT overload_request) ;
   go_error_frame_xhdl33 <= form_err OR stuff_err OR bit_err OR ack_err OR (crc_err AND go_rx_eof) ;
   error_frame_ended <= CONV_STD_LOGIC(error_cnt2 = "111") AND tx_point ;
   overload_frame_ended <= CONV_STD_LOGIC(overload_cnt2 = "111") AND tx_point ;
   go_overload_frame_xhdl32 <= (((sample_point AND ((NOT sampled_bit) OR overload_request)) AND (((rx_eof AND (NOT transmitter_xhdl8)) AND CONV_STD_LOGIC(eof_cnt = "110")) OR error_frame_ended OR overload_frame_ended)) OR (((sample_point AND (NOT sampled_bit)) AND rx_inter_xhdl11) AND CONV_STD_LOGIC(bit_cnt(1 DOWNTO 0) < "10")) OR ((sample_point AND (NOT sampled_bit)) AND CONV_STD_LOGIC((error_cnt2 = "111") OR (overload_cnt2 = "111")))) AND (NOT overload_frame_blocked) ;
   go_crc_enable <= hard_sync OR go_tx_xhdl34 ;
   rst_crc_enable <= go_rx_crc ;
   bit_de_stuff_set <= go_rx_id1 AND (NOT go_error_frame_xhdl33) ;
   bit_de_stuff_reset <= go_rx_ack OR reset_mode OR go_error_frame_xhdl33 OR go_overload_frame_xhdl32 ;
   remote_rq <= ((NOT ide) AND rtr1) OR (ide AND rtr2) ;
   temp_xhdl47 <= data_len WHEN (data_len < "1000") ELSE "1000";
   limited_data_len <= temp_xhdl47 ;
   ack_err <= (((rx_ack AND sample_point) AND sampled_bit) AND tx_state_xhdl2) AND (NOT self_test_mode) ;
   bit_err <= ((((((((tx_state_xhdl2 OR error_frame OR overload_frame_xhdl4 OR rx_ack) AND sample_point) AND CONV_STD_LOGIC(tx_xhdl29 /= sampled_bit)) AND (NOT bit_err_exc1)) AND (NOT bit_err_exc2)) AND (NOT bit_err_exc3)) AND (NOT bit_err_exc4)) AND (NOT bit_err_exc5)) AND (NOT bit_err_exc6) ;
   bit_err_exc1 <= (tx_state_xhdl2 AND arbitration_field) AND tx_xhdl29 ;
   bit_err_exc2 <= rx_ack AND tx_xhdl29 ;
   bit_err_exc3 <= (error_frame AND node_error_passive_xhdl26) AND CONV_STD_LOGIC(error_cnt1 < "111") ;
   bit_err_exc4 <= ((error_frame AND CONV_STD_LOGIC(error_cnt1 = "111")) AND (NOT enable_error_cnt2)) OR ((overload_frame_xhdl4 AND CONV_STD_LOGIC(overload_cnt1 = "111")) AND (NOT enable_overload_cnt2)) ;
   bit_err_exc5 <= (error_frame AND CONV_STD_LOGIC(error_cnt2 = "111")) OR (overload_frame_xhdl4 AND CONV_STD_LOGIC(overload_cnt2 = "111")) ;
   bit_err_exc6 <= (CONV_STD_LOGIC(eof_cnt = "110") AND rx_eof) AND (NOT transmitter_xhdl8) ;
   arbitration_field <= rx_id1 OR rx_rtr1 OR rx_ide OR rx_id2 OR rx_rtr2 ;
   last_bit_of_inter <= rx_inter_xhdl11 AND CONV_STD_LOGIC(bit_cnt(1 DOWNTO 0) = "10") ;
   not_first_bit_of_inter_xhdl10 <= rx_inter_xhdl11 AND CONV_STD_LOGIC(bit_cnt(1 DOWNTO 0) /= "00") ;

   -- Rx idle state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_idle_xhdl6 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_id1 OR go_error_frame_xhdl33) = '1') THEN
            rx_idle_xhdl6 <= '0' ;
         ELSE
            IF (go_rx_idle = '1') THEN
               rx_idle_xhdl6 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_idle_xhdl6 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx id1 state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_id1 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_rtr1 OR go_error_frame_xhdl33) = '1') THEN
            rx_id1 <= '0' ;
         ELSE
            IF (go_rx_id1 = '1') THEN
               rx_id1 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_id1 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx rtr1 state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_rtr1 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_ide OR go_error_frame_xhdl33) = '1') THEN
            rx_rtr1 <= '0' ;
         ELSE
            IF (go_rx_rtr1 = '1') THEN
               rx_rtr1 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_rtr1 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx ide state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_ide <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_r0 OR go_rx_id2 OR go_error_frame_xhdl33) = '1') THEN
            rx_ide <= '0' ;
         ELSE
            IF (go_rx_ide = '1') THEN
               rx_ide <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_ide <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx id2 state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_id2 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_rtr2 OR go_error_frame_xhdl33) = '1') THEN
            rx_id2 <= '0' ;
         ELSE
            IF (go_rx_id2 = '1') THEN
               rx_id2 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_id2 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx rtr2 state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_rtr2 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_r1 OR go_error_frame_xhdl33) = '1') THEN
            rx_rtr2 <= '0' ;
         ELSE
            IF (go_rx_rtr2 = '1') THEN
               rx_rtr2 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_rtr2 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx r0 state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_r1 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_r0 OR go_error_frame_xhdl33) = '1') THEN
            rx_r1 <= '0' ;
         ELSE
            IF (go_rx_r1 = '1') THEN
               rx_r1 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_r1 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx r0 state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_r0 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_dlc OR go_error_frame_xhdl33) = '1') THEN
            rx_r0 <= '0' ;
         ELSE
            IF (go_rx_r0 = '1') THEN
               rx_r0 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_r0 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx dlc state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_dlc <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_data OR go_rx_crc OR go_error_frame_xhdl33) = '1') THEN
            rx_dlc <= '0' ;
         ELSE
            IF (go_rx_dlc = '1') THEN
               rx_dlc <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_dlc <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx data state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_data <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_crc OR go_error_frame_xhdl33) = '1') THEN
            rx_data <= '0' ;
         ELSE
            IF (go_rx_data = '1') THEN
               rx_data <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_data <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx crc state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_crc <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_crc_lim OR go_error_frame_xhdl33) = '1') THEN
            rx_crc <= '0' ;
         ELSE
            IF (go_rx_crc = '1') THEN
               rx_crc <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_crc <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx crc delimiter state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_crc_lim <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_ack OR go_error_frame_xhdl33) = '1') THEN
            rx_crc_lim <= '0' ;
         ELSE
            IF (go_rx_crc_lim = '1') THEN
               rx_crc_lim <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_crc_lim <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx ack state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_ack <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_ack_lim OR go_error_frame_xhdl33) = '1') THEN
            rx_ack <= '0' ;
         ELSE
            IF (go_rx_ack = '1') THEN
               rx_ack <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_ack <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx ack delimiter state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_ack_lim <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_eof OR go_error_frame_xhdl33) = '1') THEN
            rx_ack_lim <= '0' ;
         ELSE
            IF (go_rx_ack_lim = '1') THEN
               rx_ack_lim <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_ack_lim <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rx eof state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_eof <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_inter_xhdl9 OR go_error_frame_xhdl33 OR go_overload_frame_xhdl32) = '1') THEN
            rx_eof <= '0' ;
         ELSE
            IF (go_rx_eof = '1') THEN
               rx_eof <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_eof <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Interframe space

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_inter_xhdl11 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_idle OR go_rx_id1 OR go_overload_frame_xhdl32 OR go_error_frame_xhdl33) = '1') THEN
            rx_inter_xhdl11 <= '0' ;
         ELSE
            IF (go_rx_inter_xhdl9 = '1') THEN
               rx_inter_xhdl11 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rx_inter_xhdl11 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- ID register

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         id <= "00000000000000000000000000000";
      IF (clk'EVENT AND clk = '1') THEN

        IF (reset_mode = '1') THEN
            id <= "00000000000000000000000000000";
         ELSE
            IF (((sample_point AND (rx_id1 OR rx_id2)) AND (NOT bit_de_stuff)) = '1') THEN
               id <= id(27 DOWNTO 0) & sampled_bit ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            id <= "00000000000000000000000000000";
         END IF;
      END IF;
   END PROCESS;

   -- rtr1 bit

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rtr1 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            rtr1 <= '0';
         ELSE
            IF (((sample_point AND rx_rtr1) AND (NOT bit_de_stuff)) = '1') THEN
               rtr1 <= sampled_bit ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rtr1 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- rtr2 bit

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rtr2 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            rtr2 <= '0';
         ELSE
            IF (((sample_point AND rx_rtr2) AND (NOT bit_de_stuff)) = '1') THEN
               rtr2 <= sampled_bit ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rtr2 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- ide bit

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         ide <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            ide <= '0';
         ELSE
            IF (((sample_point AND rx_ide) AND (NOT bit_de_stuff)) = '1') THEN
               ide <= sampled_bit ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            ide <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Data length

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         data_len <= "0000";
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            data_len <= "0000";
         ELSE
            IF (((sample_point AND rx_dlc) AND (NOT bit_de_stuff)) = '1') THEN
               data_len <= data_len(2 DOWNTO 0) & sampled_bit ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            data_len <= "0000";
         END IF;
      END IF;
   END PROCESS;

   -- Data

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         tmp_data <= "00000000";
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            tmp_data <= "00000000";
         ELSE
            IF (((sample_point AND rx_data) AND (NOT bit_de_stuff)) = '1') THEN
               tmp_data <= tmp_data(6 DOWNTO 0) & sampled_bit ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            tmp_data <= "00000000";
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         write_data_to_tmp_fifo <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            write_data_to_tmp_fifo <= '0';
         ELSE
            IF ((((sample_point AND rx_data) AND (NOT bit_de_stuff)) AND (andv(bit_cnt(2 DOWNTO 0)))) = '1') THEN
               write_data_to_tmp_fifo <= '1' ;
            ELSE
               write_data_to_tmp_fifo <= '0' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            write_data_to_tmp_fifo <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk)
   BEGIN
--      IF (rst = '1') THEN
--         byte_cnt <= "000";
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode or rst) = '1') THEN
            byte_cnt <= "000";
         ELSE
            IF (write_data_to_tmp_fifo = '1') THEN
               byte_cnt <= byte_cnt + "001" ;
            ELSE
               IF ((sample_point AND go_rx_crc_lim) = '1') THEN
                  byte_cnt <= "000" ;
               END IF;
            END IF;
         END IF;
--         IF (rst = '1') THENbyte_cnt <= "000";END IF;
      END IF;
   END PROCESS;

   process (clk, rst)
   begin
     if rising_edge(clk) then
       wr_fifo2 <= wr_fifo;
     end if;
     if rst = '1' then
       wr_fifo2 <= '0';
     end if;
   end process;

   rcv_msg_valid <= wr_fifo and not wr_fifo2;
   rcv_id        <= id when ide = '1' else id(10 downto 0) & "11" & X"FFFF";
   rcv_rtr       <= rtr2 when ide = '1' else rtr1;
   rcv_dlc       <= data_len;
   rcv_ide       <= ide;
   rcv_msg_data  <= rx_msg_data;

   process (clk)
   begin
      if (clk'EVENT AND clk = '1') then

         if (write_data_to_tmp_fifo = '1') then

           case byte_cnt is
             when "000" => rx_msg_data(63 downto 56) <= tmp_data;
             when "001" => rx_msg_data(55 downto 48) <= tmp_data;
             when "010" => rx_msg_data(47 downto 40) <= tmp_data;
             when "011" => rx_msg_data(39 downto 32) <= tmp_data;
             when "100" => rx_msg_data(31 downto 24) <= tmp_data;
             when "101" => rx_msg_data(23 downto 16) <= tmp_data;
             when "110" => rx_msg_data(15 downto 8)  <= tmp_data;
             when "111" => rx_msg_data(7 downto 0)   <= tmp_data;
             when others => null;
           end case;

         end if;

         if (rst = '1') then
            rx_msg_data  <= (others => '0');
         end if;

      end if;
   end process;

   -- CRC

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         crc_in <= "000000000000000";
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            crc_in <= "000000000000000";
         ELSE
            IF (((sample_point AND rx_crc) AND (NOT bit_de_stuff)) = '1') THEN
               crc_in <= crc_in(13 DOWNTO 0) & sampled_bit ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            crc_in <= "000000000000000";
         END IF;
      END IF;
   END PROCESS;

   -- bit_cnt

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         bit_cnt <= "000000";
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            bit_cnt <= "000000";
         ELSE
            IF ((go_rx_id1 OR go_rx_id2 OR go_rx_dlc OR go_rx_data OR go_rx_crc OR go_rx_ack OR go_rx_eof OR go_rx_inter_xhdl9 OR go_error_frame_xhdl33 OR go_overload_frame_xhdl32) = '1') THEN
               bit_cnt <= "000000" ;
            ELSE
               IF ((sample_point AND (NOT bit_de_stuff)) = '1') THEN
                  bit_cnt <= bit_cnt + "000001" ;
               END IF;
            END IF;
         END IF;
         IF (rst = '1') THEN
            bit_cnt <= "000000";
         END IF;
      END IF;
   END PROCESS;

   -- eof_cnt

   PROCESS (clk)
   BEGIN
--      IF (rst = '1') THEN
--         eof_cnt <= "000";
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode or rst) = '1') THEN
            eof_cnt <= "000";
         ELSE
            IF (sample_point = '1') THEN
               IF ((go_rx_inter_xhdl9 OR go_error_frame_xhdl33 OR go_overload_frame_xhdl32) = '1') THEN
                  eof_cnt <= "000" ;
               ELSE
                  IF (rx_eof = '1') THEN
                     eof_cnt <= eof_cnt + "001" ;
                  END IF;
               END IF;
            END IF;
         END IF;
--         IF (rst = '1') THENeof_cnt <= "000";END IF;
      END IF;
   END PROCESS;

   -- Enabling bit de-stuffing

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         bit_stuff_cnt_en <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            bit_stuff_cnt_en <= '0';
         ELSE
            IF (bit_de_stuff_set = '1') THEN
               bit_stuff_cnt_en <= '1' ;
            ELSE
               IF (bit_de_stuff_reset = '1') THEN
                  bit_stuff_cnt_en <= '0' ;
               END IF;
            END IF;
         END IF;
         IF (rst = '1') THEN
            bit_stuff_cnt_en <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- bit_stuff_cnt

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         bit_stuff_cnt <= "001";
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            bit_stuff_cnt <= "001";
         ELSE
            IF (bit_de_stuff_reset = '1') THEN
               bit_stuff_cnt <= "001" ;
            ELSE
               IF ((sample_point AND bit_stuff_cnt_en) = '1') THEN
                  IF (bit_stuff_cnt = "101") THEN
                     bit_stuff_cnt <= "001" ;
                  ELSE
                     IF (sampled_bit = sampled_bit_q) THEN
                        bit_stuff_cnt <= bit_stuff_cnt + "001" ;
                     ELSE
                        bit_stuff_cnt <= "001" ;
                     END IF;
                  END IF;
               END IF;
            END IF;
         END IF;
         IF (rst = '1') THEN
            bit_stuff_cnt <= "001";
         END IF;
      END IF;
   END PROCESS;

   -- bit_stuff_cnt_tx

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         bit_stuff_cnt_tx <= "001";
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            bit_stuff_cnt_tx <= "001";
         ELSE
            IF (bit_de_stuff_reset = '1') THEN
               bit_stuff_cnt_tx <= "001" ;
            ELSE
               IF ((tx_point_q AND bit_stuff_cnt_en) = '1') THEN
                  IF (bit_stuff_cnt_tx = "101") THEN
                     bit_stuff_cnt_tx <= "001" ;
                  ELSE
                     IF (tx_xhdl29 = tx_q) THEN
                        bit_stuff_cnt_tx <= bit_stuff_cnt_tx + "001" ;
                     ELSE
                        bit_stuff_cnt_tx <= "001" ;
                     END IF;
                  END IF;
               END IF;
            END IF;
         END IF;
         IF (rst = '1') THEN
            bit_stuff_cnt_tx <= "001";
         END IF;
      END IF;
   END PROCESS;
   bit_de_stuff <= CONV_STD_LOGIC(bit_stuff_cnt = "101") ;
   bit_de_stuff_tx <= CONV_STD_LOGIC(bit_stuff_cnt_tx = "101") ;
   -- stuff_err
   stuff_err <= ((sample_point AND bit_stuff_cnt_en) AND bit_de_stuff) AND CONV_STD_LOGIC(sampled_bit = sampled_bit_q) ;

   -- Generating delayed signals

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         reset_mode_q <= '0' ;
--         node_bus_off_q <= '0' ;
      IF (clk'EVENT AND clk = '1') THEN
         reset_mode_q <= reset_mode ;
         node_bus_off_q <= node_bus_off_xhdl13 ;
         IF (rst = '1') THEN
            reset_mode_q <= '0' ;
            node_bus_off_q <= '0' ;
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         crc_enable <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR rst_crc_enable) = '1') THEN
            crc_enable <= '0' ;
         ELSE
            IF (go_crc_enable = '1') THEN
               crc_enable <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            crc_enable <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- CRC error generation

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         crc_err <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR error_frame_ended) = '1') THEN
            crc_err <= '0' ;
         ELSE
            IF (go_rx_ack = '1') THEN
               crc_err <= CONV_STD_LOGIC(crc_in /= calculated_crc) ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            crc_err <= '0';
         END IF;
      END IF;
   END PROCESS;
   -- Conditions for form error
   form_err <= sample_point AND ((((NOT bit_de_stuff) AND rx_crc_lim) AND (NOT sampled_bit)) OR (rx_ack_lim AND (NOT sampled_bit)) OR (((CONV_STD_LOGIC(eof_cnt < "110") AND rx_eof) AND (NOT sampled_bit)) AND (NOT transmitter_xhdl8)) OR (((rx_eof) AND (NOT sampled_bit)) AND transmitter_xhdl8)) ;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         ack_err_latched <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR error_frame_ended OR go_overload_frame_xhdl32) = '1') THEN
            ack_err_latched <= '0' ;
         ELSE
            IF (ack_err = '1') THEN
               ack_err_latched <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            ack_err_latched <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         bit_err_latched <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR error_frame_ended OR go_overload_frame_xhdl32) = '1') THEN
            bit_err_latched <= '0' ;
         ELSE
            IF (bit_err = '1') THEN
               bit_err_latched <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            bit_err_latched <= '0';
         END IF;
      END IF;
   END PROCESS;
   -- Rule 5 (Fault confinement).
   rule5 <= bit_err AND ((((NOT node_error_passive_xhdl26) AND error_frame) AND CONV_STD_LOGIC(error_cnt1 < "111")) OR (overload_frame_xhdl4 AND CONV_STD_LOGIC(overload_cnt1 < "111"))) ;

   -- Rule 3 exception 1 - first part (Fault confinement).

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rule3_exc1_1 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR error_flag_over OR rule3_exc1_2) = '1') THEN
            rule3_exc1_1 <= '0' ;
         ELSE
            IF (((transmitter_xhdl8 AND node_error_passive_xhdl26) AND ack_err) = '1') THEN
               rule3_exc1_1 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rule3_exc1_1 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Rule 3 exception 1 - second part (Fault confinement).

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rule3_exc1_2 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_error_frame_xhdl33 OR rule3_exc1_2) = '1') THEN
            rule3_exc1_2 <= '0' ;
         ELSE
            IF ((((rule3_exc1_1 AND CONV_STD_LOGIC(error_cnt1 < "111")) AND sample_point) AND (NOT sampled_bit)) = '1') THEN
               rule3_exc1_2 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            rule3_exc1_2 <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         stuff_err_latched <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR error_frame_ended OR go_overload_frame_xhdl32) = '1') THEN
            stuff_err_latched <= '0' ;
         ELSE
            IF (stuff_err = '1') THEN
               stuff_err_latched <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            stuff_err_latched <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         form_err_latched <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR error_frame_ended OR go_overload_frame_xhdl32) = '1') THEN
            form_err_latched <= '0' ;
         ELSE
            IF (form_err = '1') THEN
               form_err_latched <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            form_err_latched <= '0';
         END IF;
      END IF;
   END PROCESS;

   xhdl_49 <= ((crc_enable AND sample_point) AND (NOT bit_de_stuff));
   i_can_crc_core_sync_rx : can_crc_core_sync
      PORT MAP (
         clk => clk,
         data => sampled_bit,
         enable => xhdl_49,
         initialize => go_crc_enable,
         crc => calculated_crc);

   no_byte0 <= rtr1 OR CONV_STD_LOGIC(data_len < "0001") ;
   no_byte1 <= rtr1 OR CONV_STD_LOGIC(data_len < "0010") ;

   temp_xhdl75 <= "101" WHEN ide = '1' ELSE "011";
   temp_xhdl76 <= (temp_xhdl75) WHEN extended_mode = '1' ELSE "010";
   header_len(2 DOWNTO 0) <= temp_xhdl76 ;
   storing_header <= CONV_STD_LOGIC(header_cnt < header_len) ;
   temp_xhdl77 <= (data_len - "0001") WHEN (data_len < "1000") ELSE "0111";
   temp_xhdl78 <= "1111" WHEN remote_rq = '1' ELSE (temp_xhdl77);
   limited_data_len_minus1(3 DOWNTO 0) <= temp_xhdl78 ;
   reset_wr_fifo <= CONV_STD_LOGIC(data_cnt = (limited_data_len_minus1 + ('0' & header_len))) OR reset_mode ;
   err <= form_err OR stuff_err OR bit_err OR ack_err OR form_err_latched OR stuff_err_latched OR bit_err_latched OR ack_err_latched OR crc_err ;


   id_ok <= '1';

   -- Write enable signal for 64-byte rx fifo

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         wr_fifo <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_wr_fifo = '1') THEN
            wr_fifo <= '0' ;
         ELSE
            IF ((((go_rx_inter_xhdl9 AND id_ok) AND (NOT error_frame_ended)) AND ((NOT tx_state_xhdl2) OR self_rx_request)) = '1') THEN
               wr_fifo <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            wr_fifo <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Header counter. Header length depends on the mode of operation and frame format.

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         header_cnt <= "000";
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_wr_fifo = '1') THEN
            header_cnt <= "000" ;
         ELSE
            IF ((wr_fifo AND storing_header) = '1') THEN
               header_cnt <= header_cnt + "001" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            header_cnt <= "000";
         END IF;
      END IF;
   END PROCESS;

   -- Data counter. Length of the data is limited to 8 bytes.

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         data_cnt <= "0000";
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_wr_fifo = '1') THEN
            data_cnt <= "0000" ;
         ELSE
            IF (wr_fifo = '1') THEN
               data_cnt <= data_cnt + "0001" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            data_cnt <= "0000";
         END IF;
      END IF;
   END PROCESS;

   -- Transmitting error frame.

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         error_frame <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR error_frame_ended OR go_overload_frame_xhdl32) = '1') THEN
            error_frame <= '0' ;
         ELSE
            IF (go_error_frame_xhdl33 = '1') THEN
               error_frame <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            error_frame <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         error_cnt1 <= "000";
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR error_frame_ended OR go_error_frame_xhdl33 OR go_overload_frame_xhdl32) = '1') THEN
            error_cnt1 <= "000" ;
         ELSE
            IF (((error_frame AND tx_point) AND CONV_STD_LOGIC(error_cnt1 < "111")) = '1') THEN
               error_cnt1 <= error_cnt1 + "001" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            error_cnt1 <= "000";
         END IF;
      END IF;
   END PROCESS;
   error_flag_over <= ((((NOT node_error_passive_xhdl26) AND sample_point) AND CONV_STD_LOGIC(error_cnt1 = "111")) OR ((node_error_passive_xhdl26 AND sample_point) AND CONV_STD_LOGIC(passive_cnt = "110"))) AND (NOT enable_error_cnt2) ;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         error_flag_over_latched <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR error_frame_ended OR go_error_frame_xhdl33 OR go_overload_frame_xhdl32) = '1') THEN
            error_flag_over_latched <= '0' ;
         ELSE
            IF (error_flag_over = '1') THEN
               error_flag_over_latched <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            error_flag_over_latched <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         enable_error_cnt2 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR error_frame_ended OR go_error_frame_xhdl33 OR go_overload_frame_xhdl32) = '1') THEN
            enable_error_cnt2 <= '0' ;
         ELSE
            IF ((error_frame AND (error_flag_over AND sampled_bit)) = '1') THEN
               enable_error_cnt2 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            enable_error_cnt2 <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         error_cnt2 <= "000";
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR error_frame_ended OR go_error_frame_xhdl33 OR go_overload_frame_xhdl32) = '1') THEN
            error_cnt2 <= "000" ;
         ELSE
            IF ((enable_error_cnt2 AND tx_point) = '1') THEN
               error_cnt2 <= error_cnt2 + "001" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            error_cnt2 <= "000";
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         delayed_dominant_cnt <= "000";
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR enable_error_cnt2 OR go_error_frame_xhdl33 OR enable_overload_cnt2 OR go_overload_frame_xhdl32) = '1') THEN
            delayed_dominant_cnt <= "000" ;
         ELSE
            IF (((sample_point AND (NOT sampled_bit)) AND CONV_STD_LOGIC((error_cnt1 = "111") OR (overload_cnt1 = "111"))) = '1') THEN
               delayed_dominant_cnt <= delayed_dominant_cnt + "001" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            delayed_dominant_cnt <= "000";
         END IF;
      END IF;
   END PROCESS;

   -- passive_cnt

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         passive_cnt <= "001";
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR error_frame_ended OR go_error_frame_xhdl33 OR go_overload_frame_xhdl32 OR first_compare_bit) = '1') THEN
            passive_cnt <= "001" ;
         ELSE
            IF ((sample_point AND CONV_STD_LOGIC(passive_cnt < "110")) = '1') THEN
               IF (((error_frame AND (NOT enable_error_cnt2)) AND CONV_STD_LOGIC(sampled_bit = sampled_bit_q)) = '1') THEN
                  passive_cnt <= passive_cnt + "001" ;
               ELSE
                  passive_cnt <= "001" ;
               END IF;
            END IF;
         END IF;
         IF (rst = '1') THEN
            passive_cnt <= "001";
         END IF;
      END IF;
   END PROCESS;

   -- When comparing 6 equal bits, first is always equal

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         first_compare_bit <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (go_error_frame_xhdl33 = '1') THEN
            first_compare_bit <= '1' ;
         ELSE
            IF (sample_point = '1') THEN
               first_compare_bit <= '0';
            END IF;
         END IF;
         IF (rst = '1') THEN
            first_compare_bit <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Transmitting overload frame.

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         overload_frame_xhdl4 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR overload_frame_ended OR go_error_frame_xhdl33) = '1') THEN
            overload_frame_xhdl4 <= '0' ;
         ELSE
            IF (go_overload_frame_xhdl32 = '1') THEN
               overload_frame_xhdl4 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            overload_frame_xhdl4 <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         overload_cnt1 <= "000";
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR overload_frame_ended OR go_error_frame_xhdl33 OR go_overload_frame_xhdl32) = '1') THEN
            overload_cnt1 <= "000" ;
         ELSE
            IF (((overload_frame_xhdl4 AND tx_point) AND CONV_STD_LOGIC(overload_cnt1 < "111")) = '1') THEN
               overload_cnt1 <= overload_cnt1 + "001" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            overload_cnt1 <= "000";
         END IF;
      END IF;
   END PROCESS;
   overload_flag_over <= (sample_point AND CONV_STD_LOGIC(overload_cnt1 = "111")) AND (NOT enable_overload_cnt2) ;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         enable_overload_cnt2 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR overload_frame_ended OR go_error_frame_xhdl33 OR go_overload_frame_xhdl32) = '1') THEN
            enable_overload_cnt2 <= '0' ;
         ELSE
            IF ((overload_frame_xhdl4 AND (overload_flag_over AND sampled_bit)) = '1') THEN
               enable_overload_cnt2 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            enable_overload_cnt2 <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         overload_cnt2 <= "000";
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR overload_frame_ended OR go_error_frame_xhdl33 OR go_overload_frame_xhdl32) = '1') THEN
            overload_cnt2 <= "000" ;
         ELSE
            IF ((enable_overload_cnt2 AND tx_point) = '1') THEN
               overload_cnt2 <= overload_cnt2 + "001" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            overload_cnt2 <= "000";
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         overload_request_cnt <= "00";
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_error_frame_xhdl33 OR go_rx_id1) = '1') THEN
            overload_request_cnt <= "00" ;
         ELSE
            IF ((overload_request AND overload_frame_xhdl4) = '1') THEN
               overload_request_cnt <= overload_request_cnt + "01" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            overload_request_cnt <= "00";
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         overload_frame_blocked <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_error_frame_xhdl33 OR go_rx_id1) = '1') THEN
            overload_frame_blocked <= '0' ;
         ELSE
            IF (((overload_request AND overload_frame_xhdl4) AND CONV_STD_LOGIC(overload_request_cnt = "10")) = '1') THEN
               -- This is a second sequential overload_request

               overload_frame_blocked <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            overload_frame_blocked <= '0';
         END IF;
      END IF;
   END PROCESS;
   send_ack_xhdl35 <= (((NOT tx_state_xhdl2) AND rx_ack) AND (NOT err)) AND (NOT listen_only_mode) ;

   PROCESS (reset_mode, node_bus_off_xhdl13, tx_state_xhdl2, go_tx_xhdl34, bit_de_stuff_tx, tx_bit, tx_q, send_ack_xhdl35, go_overload_frame_xhdl32, overload_frame_xhdl4, overload_cnt1, go_error_frame_xhdl33, error_frame, error_cnt1, node_error_passive_xhdl26)
      VARIABLE tx_next_xhdl30_xhdl105  : std_logic;
   BEGIN
      IF ((reset_mode OR node_bus_off_xhdl13) = '1') THEN
         -- Reset or node_bus_off

         tx_next_xhdl30_xhdl105 := '1';
      ELSE
         IF ((go_error_frame_xhdl33 OR error_frame) = '1') THEN
            -- Transmitting error frame

            IF (error_cnt1 < "110") THEN
               IF (node_error_passive_xhdl26 = '1') THEN
                  tx_next_xhdl30_xhdl105 := '1';
               ELSE
                  tx_next_xhdl30_xhdl105 := '0';
               END IF;
            ELSE
               tx_next_xhdl30_xhdl105 := '1';
            END IF;
         ELSE
            IF ((go_overload_frame_xhdl32 OR overload_frame_xhdl4) = '1') THEN
               -- Transmitting overload frame

               IF (overload_cnt1 < "110") THEN
                  tx_next_xhdl30_xhdl105 := '0';
               ELSE
                  tx_next_xhdl30_xhdl105 := '1';
               END IF;
            ELSE
               IF ((go_tx_xhdl34 OR tx_state_xhdl2) = '1') THEN
                  -- Transmitting message

                  tx_next_xhdl30_xhdl105 := ((NOT bit_de_stuff_tx) AND tx_bit) OR (bit_de_stuff_tx AND (NOT tx_q));
               ELSE
                  IF (send_ack_xhdl35 = '1') THEN
                     -- Acknowledge

                     tx_next_xhdl30_xhdl105 := '0';
                  ELSE
                     tx_next_xhdl30_xhdl105 := '1';
                  END IF;
               END IF;
            END IF;
         END IF;
      END IF;
      tx_next_xhdl30 <= tx_next_xhdl30_xhdl105;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         tx_xhdl29 <= '1';
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            tx_xhdl29 <= '1';
         ELSE
            IF (tx_point = '1') THEN
               tx_xhdl29 <= tx_next_xhdl30 ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            tx_xhdl29 <= '1';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         tx_q <= '0' ;
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            tx_q <= '0' ;
         ELSE
            IF (tx_point = '1') THEN
               tx_q <= tx_xhdl29 AND (NOT go_early_tx_latched) ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            tx_q <= '0' ;
         END IF;
      END IF;
   END PROCESS;

   -- Delayed tx point
   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         tx_point_q <= '0' ;
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            tx_point_q <= '0' ;
         ELSE
            tx_point_q <= tx_point ;
         END IF;
         IF (rst = '1') THEN
            tx_point_q <= '0' ;
         END IF;
      END IF;
   END PROCESS;

   -- Changing bit order from [7:0] to [0:7]
   i_ibo_tx_data_0 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_0,
         do => r_tx_data_0);

   i_ibo_tx_data_1 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_1,
         do => r_tx_data_1);

   i_ibo_tx_data_2 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_2,
         do => r_tx_data_2);

   i_ibo_tx_data_3 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_3,
         do => r_tx_data_3);

   i_ibo_tx_data_4 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_4,
         do => r_tx_data_4);

   i_ibo_tx_data_5 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_5,
         do => r_tx_data_5);

   i_ibo_tx_data_6 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_6,
         do => r_tx_data_6);

   i_ibo_tx_data_7 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_7,
         do => r_tx_data_7);

   i_ibo_tx_data_8 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_8,
         do => r_tx_data_8);

   i_ibo_tx_data_9 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_9,
         do => r_tx_data_9);

   i_ibo_tx_data_10 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_10,
         do => r_tx_data_10);

   i_ibo_tx_data_11 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_11,
         do => r_tx_data_11);

   i_ibo_tx_data_12 : can_ibo_core_sync
      PORT MAP (
         di => tx_data_12,
         do => r_tx_data_12);


   -- Changing bit order from [14:0] to [0:14]
   i_calculated_crc0 : can_ibo_core_sync
      PORT MAP (
         di => calculated_crc(14 DOWNTO 7),
         do => r_calculated_crc(7 DOWNTO 0));

   xhdl_106 <= calculated_crc(6 DOWNTO 0) & '0';
   i_calculated_crc1 : can_ibo_core_sync
      PORT MAP (
         di => xhdl_106,
         do => r_calculated_crc(15 DOWNTO 8));

   basic_chain <= r_tx_data_1(7 DOWNTO 4) & "00" & r_tx_data_1(3 DOWNTO 0) & r_tx_data_0(7 DOWNTO 0) & '0' ;
   basic_chain_data <= r_tx_data_9 & r_tx_data_8 & r_tx_data_7 & r_tx_data_6 & r_tx_data_5 & r_tx_data_4 & r_tx_data_3 & r_tx_data_2 ;
   extended_chain_std <= r_tx_data_0(7 DOWNTO 4) & "00" & r_tx_data_0(1) & r_tx_data_2(2 DOWNTO 0) & r_tx_data_1(7 DOWNTO 0) & '0' ;
   extended_chain_ext <= r_tx_data_0(7 DOWNTO 4) & "00" & r_tx_data_0(1) & r_tx_data_4(4 DOWNTO 0) & r_tx_data_3(7 DOWNTO 0) & r_tx_data_2(7 DOWNTO 3) & '1' & '1' & r_tx_data_2(2 DOWNTO 0) & r_tx_data_1(7 DOWNTO 0) & '0' ;
   extended_chain_data_std <= r_tx_data_10 & r_tx_data_9 & r_tx_data_8 & r_tx_data_7 & r_tx_data_6 & r_tx_data_5 & r_tx_data_4 & r_tx_data_3 ;
   extended_chain_data_ext <= r_tx_data_12 & r_tx_data_11 & r_tx_data_10 & r_tx_data_9 & r_tx_data_8 & r_tx_data_7 & r_tx_data_6 & r_tx_data_5 ;

   PROCESS (extended_mode, rx_data, tx_pointer, extended_chain_data_std, extended_chain_data_ext, rx_crc, r_calculated_crc, r_tx_data_0, extended_chain_ext, extended_chain_std, basic_chain_data, basic_chain, finish_msg)
      VARIABLE tx_bit_xhdl107  : std_logic;
   BEGIN
      IF (extended_mode = '1') THEN
         IF (rx_data = '1') THEN
            -- data stage

            IF (r_tx_data_0(0) = '1') THEN
               -- Extended frame

               tx_bit_xhdl107 := extended_chain_data_ext(conv_integer(tx_pointer));
            ELSE
               tx_bit_xhdl107 := extended_chain_data_std(conv_integer(tx_pointer));
            END IF;
         ELSE
            IF (rx_crc = '1') THEN
               tx_bit_xhdl107 := r_calculated_crc(conv_integer(tx_pointer(3 downto 0)));
            ELSE
               IF (finish_msg = '1') THEN
                  tx_bit_xhdl107 := '1';
               ELSE
                  IF (r_tx_data_0(0) = '1') THEN
                     -- Extended frame

                     tx_bit_xhdl107 := extended_chain_ext(conv_integer(tx_pointer));
                  ELSE
                     tx_bit_xhdl107 := extended_chain_std(conv_integer(tx_pointer));
                  END IF;
               END IF;
            END IF;
         END IF;
      ELSE
         -- Basic mode

         IF (rx_data = '1') THEN
            -- data stage

            tx_bit_xhdl107 := basic_chain_data(conv_integer(tx_pointer));
         ELSE
            IF (rx_crc = '1') THEN
               tx_bit_xhdl107 := r_calculated_crc(conv_integer(tx_pointer));
            ELSE
               IF (finish_msg = '1') THEN
                  tx_bit_xhdl107 := '1';
               ELSE
                  tx_bit_xhdl107 := basic_chain(conv_integer(tx_pointer));
               END IF;
            END IF;
         END IF;
      END IF;
      tx_bit <= tx_bit_xhdl107;
   END PROCESS;
   temp_xhdl108 <= "111111" WHEN tx_data_0(3) = '1' ELSE ((tx_data_0(2 DOWNTO 0) & "000") - 1);
   limited_tx_cnt_ext <= temp_xhdl108 ;
   temp_xhdl109 <= "111111" WHEN tx_data_1(3) = '1' ELSE ((tx_data_1(2 DOWNTO 0) & "000") - 1);
   limited_tx_cnt_std <= temp_xhdl109 ;
   -- arbitration + control for extended format
   -- arbitration + control for extended format
   -- arbitration + control for standard format
   -- data       (overflow is OK here)
   -- data       (overflow is OK here)
   -- crc
   -- at the end
   rst_tx_pointer <= ((((((NOT bit_de_stuff_tx) AND tx_point) AND (NOT rx_data)) AND extended_mode) AND r_tx_data_0(0)) AND CONV_STD_LOGIC(tx_pointer = "100110")) OR ((((((NOT bit_de_stuff_tx) AND tx_point) AND (NOT rx_data)) AND extended_mode) AND (NOT r_tx_data_0(0))) AND CONV_STD_LOGIC(tx_pointer = "010010")) OR (((((NOT bit_de_stuff_tx) AND tx_point) AND (NOT rx_data)) AND (NOT extended_mode)) AND CONV_STD_LOGIC(tx_pointer = "010010")) OR (((((NOT bit_de_stuff_tx) AND tx_point) AND rx_data) AND extended_mode) AND CONV_STD_LOGIC(tx_pointer = limited_tx_cnt_ext)) OR (((((NOT bit_de_stuff_tx) AND tx_point) AND rx_data) AND (NOT extended_mode)) AND CONV_STD_LOGIC(tx_pointer = limited_tx_cnt_std)) OR (tx_point AND rx_crc_lim) OR (go_rx_idle) OR (reset_mode) OR (overload_frame_xhdl4) OR (error_frame) ;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         tx_pointer <= "000000";
      IF (clk'EVENT AND clk = '1') THEN
         IF (rst_tx_pointer = '1') THEN
            tx_pointer <= "000000" ;
         ELSE
            IF ((go_early_tx OR ((tx_point AND (tx_state_xhdl2 OR go_tx_xhdl34)) AND (NOT bit_de_stuff_tx))) = '1') THEN
               tx_pointer <= tx_pointer + "000001" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            tx_pointer <= "000000";
         END IF;
      END IF;
   END PROCESS;
   tx_successful_xhdl19 <= ((((transmitter_xhdl8 AND go_rx_inter_xhdl9) AND (NOT go_error_frame_xhdl33)) AND (NOT error_frame_ended)) AND (NOT overload_frame_ended)) AND (NOT arbitration_lost) ;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         need_to_tx_xhdl20 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((tx_successful_xhdl19 OR reset_mode OR (abort_tx AND (NOT transmitting_xhdl7)) OR (((NOT tx_state_xhdl2) AND tx_state_q_xhdl3) AND single_shot_transmission)) = '1') THEN
            need_to_tx_xhdl20 <= '0' ;
         ELSE
            IF ((tx_request AND sample_point) = '1') THEN
               need_to_tx_xhdl20 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            need_to_tx_xhdl20 <= '0';
         END IF;
      END IF;
   END PROCESS;
   go_early_tx <= ((((((NOT listen_only_mode) AND need_to_tx_xhdl20) AND (NOT tx_state_xhdl2)) AND (NOT suspend OR CONV_STD_LOGIC(susp_cnt = "111"))) AND sample_point) AND (NOT sampled_bit)) AND (rx_idle_xhdl6 OR last_bit_of_inter) ;
   go_tx_xhdl34 <= ((((NOT listen_only_mode) AND need_to_tx_xhdl20) AND (NOT tx_state_xhdl2)) AND (NOT suspend OR (sample_point AND CONV_STD_LOGIC(susp_cnt = "111")))) AND (go_early_tx OR rx_idle_xhdl6) ;

   -- go_early_tx latched (for proper bit_de_stuff generation)

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         go_early_tx_latched <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR tx_point) = '1') THEN
            go_early_tx_latched <= '0' ;
         ELSE
            IF (go_early_tx = '1') THEN
               go_early_tx_latched <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            go_early_tx_latched <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Tx state

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         tx_state_xhdl2 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR go_rx_inter_xhdl9 OR error_frame OR arbitration_lost) = '1') THEN
            tx_state_xhdl2 <= '0' ;
         ELSE
            IF (go_tx_xhdl34 = '1') THEN
               tx_state_xhdl2 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            tx_state_xhdl2 <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         tx_state_q_xhdl3 <= '0' ;
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            tx_state_q_xhdl3 <= '0' ;
         ELSE
            tx_state_q_xhdl3 <= tx_state_xhdl2 ;
         END IF;
         IF (rst = '1') THEN
            tx_state_q_xhdl3 <= '0' ;
         END IF;
      END IF;
   END PROCESS;

   -- Node is a transmitter

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         transmitter_xhdl8 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (go_tx_xhdl34 = '1') THEN
            transmitter_xhdl8 <= '1' ;
         ELSE
            IF ((reset_mode OR go_rx_idle or (suspend AND go_rx_id1)) = '1') THEN
               transmitter_xhdl8 <= '0' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            transmitter_xhdl8 <= '0';
         END IF;
      END IF;
   END PROCESS;

   -- Signal "transmitting" signals that the core is a transmitting (message, error frame or overload frame). No synchronization is done meanwhile.
   -- Node might be both transmitter or receiver (sending error or overload frame)

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         transmitting_xhdl7 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((go_error_frame_xhdl33 OR go_overload_frame_xhdl32 OR go_tx_xhdl34 OR send_ack_xhdl35) = '1') THEN
            transmitting_xhdl7 <= '1' ;
         ELSE
            IF ((reset_mode OR go_rx_idle OR (go_rx_id1 AND (NOT tx_state_xhdl2)) OR (arbitration_lost AND tx_state_xhdl2)) = '1') THEN
               transmitting_xhdl7 <= '0' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            transmitting_xhdl7 <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         suspend <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR (sample_point AND CONV_STD_LOGIC(susp_cnt = "111"))) = '1') THEN
            suspend <= '0' ;
         ELSE
            IF (((not_first_bit_of_inter_xhdl10 AND transmitter_xhdl8) AND node_error_passive_xhdl26) = '1') THEN
               suspend <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            suspend <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         susp_cnt_en <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR (sample_point AND CONV_STD_LOGIC(susp_cnt = "111"))) = '1') THEN
            susp_cnt_en <= '0' ;
         ELSE
            IF (((suspend AND sample_point) AND last_bit_of_inter) = '1') THEN
               susp_cnt_en <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            susp_cnt_en <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         susp_cnt <= "000";
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR (sample_point AND CONV_STD_LOGIC(susp_cnt = "111"))) = '1') THEN
            susp_cnt <= "000" ;
         ELSE
            IF ((susp_cnt_en AND sample_point) = '1') THEN
               susp_cnt <= susp_cnt + "001" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            susp_cnt <= "000";
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         finish_msg <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((go_rx_idle OR go_rx_id1 OR error_frame OR reset_mode) = '1') THEN
            finish_msg <= '0' ;
         ELSE
            IF (go_rx_crc_lim = '1') THEN
               finish_msg <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            finish_msg <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         arbitration_lost <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((go_rx_idle OR error_frame_ended OR reset_mode) = '1') THEN
            arbitration_lost <= '0' ;
         ELSE
            IF (((((transmitter_xhdl8 AND sample_point) AND tx_xhdl29) AND arbitration_field) AND NOT sampled_bit) = '1') THEN
               arbitration_lost <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            arbitration_lost <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         arbitration_lost_q <= '0' ;
--         read_arbitration_lost_capture_reg_q <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            arbitration_lost_q <= '0';
            read_arbitration_lost_capture_reg_q <= '0';
         ELSE
            arbitration_lost_q <= arbitration_lost;
            read_arbitration_lost_capture_reg_q <= read_arbitration_lost_capture_reg ;
         END IF;
         IF (rst = '1') THEN
            arbitration_lost_q <= '0' ;
            read_arbitration_lost_capture_reg_q <= '0';
         END IF;
      END IF;
   END PROCESS;
   set_arbitration_lost_irq_xhdl24 <= (arbitration_lost AND (NOT arbitration_lost_q)) AND (NOT arbitration_blocked) ;

   PROCESS (clk, rst)
   BEGIN
--     IF (rst = '1') THEN
--       read_error_code_capture_reg_q <= '0';
     IF (clk'EVENT AND clk = '1') THEN
       read_error_code_capture_reg_q <= read_error_code_capture_reg;
        IF (rst = '1') THEN
          read_error_code_capture_reg_q <= '0';
        END IF;
     END IF;
   END PROCESS;

   reset_error_code_capture_reg <= read_error_code_capture_reg_q and not read_error_code_capture_reg;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         arbitration_cnt_en <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR arbitration_blocked) = '1') THEN
            arbitration_cnt_en <= '0' ;
         ELSE
            IF (((rx_id1 AND sample_point) AND (NOT arbitration_blocked)) = '1') THEN
               arbitration_cnt_en <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            arbitration_cnt_en <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         arbitration_blocked <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((reset_mode OR read_arbitration_lost_capture_reg) = '1') THEN
            arbitration_blocked <= '0' ;
         ELSE
            IF (set_arbitration_lost_irq_xhdl24 = '1') THEN
               arbitration_blocked <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            arbitration_blocked <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         arbitration_lost_capture_xhdl25 <= "00000";
      IF (clk'EVENT AND clk = '1') THEN
         IF (read_arbitration_lost_capture_reg_q = '1') THEN
            arbitration_lost_capture_xhdl25 <= "00000" ;
         ELSE
            IF ((((sample_point AND (NOT arbitration_blocked)) AND arbitration_cnt_en) AND (NOT bit_de_stuff)) = '1') THEN
               arbitration_lost_capture_xhdl25 <= arbitration_lost_capture_xhdl25 + "00001" ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            arbitration_lost_capture_xhdl25 <= "00000";
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         rx_err_cnt_xhdl15 <= "000000000";
     IF (clk'EVENT AND clk = '1') THEN
      IF (set_reset_mode_xhdl12 = '1') THEN
         rx_err_cnt_xhdl15 <= "000000000" ;
      else
          IF (((NOT listen_only_mode) AND (NOT transmitter_xhdl8 OR arbitration_lost)) = '1') THEN
            IF ((((go_rx_ack_lim AND (NOT go_error_frame_xhdl33)) AND (NOT crc_err)) AND CONV_STD_LOGIC(rx_err_cnt_xhdl15 > "000000000")) = '1') THEN
              IF (rx_err_cnt_xhdl15 > "001111111") THEN
                rx_err_cnt_xhdl15 <= "001111111" ;
              ELSE
                rx_err_cnt_xhdl15 <= rx_err_cnt_xhdl15 - "000000001" ;
              END IF;
            ELSE
              IF (rx_err_cnt_xhdl15 < "010000000") THEN
                IF ((go_error_frame_xhdl33 AND (NOT rule5)) = '1') THEN
                  -- 1  (rule 5 is just the opposite then rule 1 exception

                  rx_err_cnt_xhdl15 <= rx_err_cnt_xhdl15 + "000000001" ;
                ELSE
                  IF ((((((error_flag_over AND (NOT error_flag_over_latched)) AND sample_point) AND (NOT sampled_bit)) AND CONV_STD_LOGIC(error_cnt1 = "111")) OR (go_error_frame_xhdl33 AND rule5) OR ((sample_point AND (NOT sampled_bit)) AND CONV_STD_LOGIC(delayed_dominant_cnt = "111"))) = '1') THEN
                    -- 2
                    -- 5
                    -- 6

                    rx_err_cnt_xhdl15 <= rx_err_cnt_xhdl15 + "000001000" ;
                  END IF;
                END IF;
              END IF;
            END IF;
          END IF;
       end if;
       IF (rst = '1') THEN
         rx_err_cnt_xhdl15 <= "000000000";
       END IF;
     END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         tx_err_cnt_xhdl16 <= "000000000";
     IF (clk'EVENT AND clk = '1') THEN
      IF (set_reset_mode_xhdl12 = '1') THEN
         tx_err_cnt_xhdl16 <= "010000000" ;
      ELSE
          IF ((CONV_STD_LOGIC(tx_err_cnt_xhdl16 > "000000000") AND (tx_successful_xhdl19 OR bus_free)) = '1') THEN
            tx_err_cnt_xhdl16 <= tx_err_cnt_xhdl16 - "000000001" ;
          ELSE
            IF ((transmitter_xhdl8 AND (NOT arbitration_lost)) = '1') THEN
              IF ((((sample_point AND (NOT sampled_bit)) AND CONV_STD_LOGIC(delayed_dominant_cnt = "111")) OR (go_error_frame_xhdl33 AND rule5) OR ((go_error_frame_xhdl33 AND (NOT ((transmitter_xhdl8 AND node_error_passive_xhdl26) AND ack_err))) AND (NOT (((((transmitter_xhdl8 AND stuff_err) AND arbitration_field) AND sample_point) AND tx_xhdl29) AND (NOT sampled_bit)))) OR (error_frame AND rule3_exc1_2)) = '1') THEN
                -- 6
                -- 4  (rule 5 is the same as rule 4)
                -- 3
                -- 3

                tx_err_cnt_xhdl16 <= tx_err_cnt_xhdl16 + "000001000" ;
              END IF;
            END IF;
          END IF;
       end if;
       IF (rst = '1') THEN
         tx_err_cnt_xhdl16 <= "000000000";
       END IF;
     END IF;
   END PROCESS;

   set_reset_mode_xhdl12 <= node_bus_off_xhdl13 AND (NOT node_bus_off_q) ; --##

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         node_error_passive_xhdl26 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((rx_err_cnt_xhdl15 < "010000000") AND (tx_err_cnt_xhdl16 < "010000000")) THEN
            node_error_passive_xhdl26 <= '0' ;
         ELSE
            IF (((CONV_STD_LOGIC((rx_err_cnt_xhdl15 >= "010000000") OR (tx_err_cnt_xhdl16 >= "010000000")) AND (error_frame_ended OR go_error_frame_xhdl33 OR ((NOT reset_mode) AND reset_mode_q))) AND (NOT node_bus_off_xhdl13)) = '1') THEN
               node_error_passive_xhdl26 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            node_error_passive_xhdl26 <= '0';
         END IF;
      END IF;
   END PROCESS;
   node_error_active_xhdl27 <= NOT (node_error_passive_xhdl26 OR node_bus_off_xhdl13) ;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         node_bus_off_xhdl13 <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ( (CONV_STD_LOGIC((rx_err_cnt_xhdl15 = "000000000") AND (tx_err_cnt_xhdl16 = "000000000")) AND (NOT reset_mode)) = '1' or restart = '1') THEN
            node_bus_off_xhdl13 <= '0' ;
         ELSE
            IF (CONV_STD_LOGIC(tx_err_cnt_xhdl16 >= "100000000") = '1') THEN
               node_bus_off_xhdl13 <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            node_bus_off_xhdl13 <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         bus_free_cnt <= "0000";
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            bus_free_cnt <= "0000" ;
         ELSE
            IF (sample_point = '1') THEN
               IF (((sampled_bit AND bus_free_cnt_en) AND CONV_STD_LOGIC(bus_free_cnt < "1010")) = '1') THEN
                  bus_free_cnt <= bus_free_cnt + "0001" ;
               ELSE
                  bus_free_cnt <= "0000" ;
               END IF;
            END IF;
         END IF;
         IF (rst = '1') THEN
            bus_free_cnt <= "0000";
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         bus_free_cnt_en <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF ((((NOT reset_mode) AND reset_mode_q) OR (node_bus_off_q AND (NOT reset_mode))) = '1') THEN
            bus_free_cnt_en <= '1' ;
         ELSE
            IF ((((sample_point AND sampled_bit) AND CONV_STD_LOGIC(bus_free_cnt = "1010")) AND (NOT node_bus_off_xhdl13)) = '1') THEN
               bus_free_cnt_en <= '0' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            bus_free_cnt_en <= '1';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         bus_free <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            bus_free <= '0';
         ELSE
            IF (((sample_point AND sampled_bit) AND CONV_STD_LOGIC(bus_free_cnt = "1010")) = '1') THEN
               bus_free <= '1' ;
            ELSE
               bus_free <= '0' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            bus_free <= '0';
         END IF;
      END IF;
   END PROCESS;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         waiting_for_bus_free <= '1';
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_mode = '1') THEN
            waiting_for_bus_free <= '1';
         ELSE
            IF ((bus_free AND (NOT node_bus_off_xhdl13)) = '1') THEN
               waiting_for_bus_free <= '0' ;
            ELSE
               IF ((((NOT reset_mode) AND reset_mode_q) OR (node_bus_off_q AND (NOT reset_mode))) = '1') THEN
                  waiting_for_bus_free <= '1' ;
               END IF;
            END IF;
         END IF;
         IF (rst = '1') THEN
            waiting_for_bus_free <= '1';
         END IF;
      END IF;
   END PROCESS;
   transmit_status_xhdl17 <= transmitting_xhdl7 OR (extended_mode AND waiting_for_bus_free) ;
   temp_xhdl111 <= (waiting_for_bus_free OR ((NOT rx_idle_xhdl6) AND (NOT transmitting_xhdl7))) WHEN extended_mode = '1' ELSE (((NOT waiting_for_bus_free) AND (NOT rx_idle_xhdl6)) AND (NOT transmitting_xhdl7));
   receive_status_xhdl18 <= temp_xhdl111 ;

   -- Error code capture register
   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         error_capture_code_xhdl5 <= "00000000";
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset_error_code_capture_reg = '1') THEN
            error_capture_code_xhdl5 <= "00000000" ;
         ELSE
            IF (set_bus_error_irq_xhdl23 = '1') THEN
               error_capture_code_xhdl5 <= error_capture_code_type(7 DOWNTO 6) & error_capture_code_direction & error_capture_code_segment(4 DOWNTO 0) ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            error_capture_code_xhdl5 <= "00000000";
         END IF;
      END IF;
   END PROCESS;
   error_capture_code_segment(0) <= rx_idle_xhdl6 OR rx_ide OR (rx_id2 AND CONV_STD_LOGIC(bit_cnt < "001101")) OR rx_r1 OR rx_r0 OR rx_dlc OR rx_ack OR rx_ack_lim OR (error_frame AND node_error_active_xhdl27) ;
   error_capture_code_segment(1) <= rx_idle_xhdl6 OR rx_id1 OR rx_id2 OR rx_dlc OR rx_data OR rx_ack_lim OR rx_eof OR rx_inter_xhdl11 OR (error_frame AND node_error_passive_xhdl26) ;
   error_capture_code_segment(2) <= (rx_id1 AND CONV_STD_LOGIC(bit_cnt > "000111")) OR rx_rtr1 OR rx_ide OR rx_id2 OR rx_rtr2 OR rx_r1 OR (error_frame AND node_error_passive_xhdl26) OR overload_frame_xhdl4 ;
   error_capture_code_segment(3) <= (rx_id2 AND CONV_STD_LOGIC(bit_cnt > "000100")) OR rx_rtr2 OR rx_r1 OR rx_r0 OR rx_dlc OR rx_data OR rx_crc OR rx_crc_lim OR rx_ack OR rx_ack_lim OR rx_eof OR overload_frame_xhdl4 ;
   error_capture_code_segment(4) <= rx_crc_lim OR rx_ack OR rx_ack_lim OR rx_eof OR rx_inter_xhdl11 OR error_frame OR overload_frame_xhdl4 ;
   error_capture_code_direction <= NOT transmitting_xhdl7 ;

   PROCESS (bit_err, form_err, stuff_err)
      VARIABLE error_capture_code_type_xhdl112  : std_logic_vector(7 DOWNTO 6);
   BEGIN
      IF (bit_err = '1') THEN
         error_capture_code_type_xhdl112(7 DOWNTO 6) := "00";
      ELSE
         IF (form_err = '1') THEN
            error_capture_code_type_xhdl112(7 DOWNTO 6) := "01";
         ELSE
            IF (stuff_err = '1') THEN
               error_capture_code_type_xhdl112(7 DOWNTO 6) := "10";
            ELSE
               error_capture_code_type_xhdl112(7 DOWNTO 6) := "11";
            END IF;
         END IF;
      END IF;
      error_capture_code_type <= error_capture_code_type_xhdl112;
   END PROCESS;
   set_bus_error_irq_xhdl23 <= go_error_frame_xhdl33 AND (NOT error_capture_code_blocked) ;

   PROCESS (clk, rst)
   BEGIN
--      IF (rst = '1') THEN
--         error_capture_code_blocked <= '0';
      IF (clk'EVENT AND clk = '1') THEN
         IF (read_error_code_capture_reg = '1') THEN
            error_capture_code_blocked <= '0' ;
         ELSE
            IF (set_bus_error_irq_xhdl23 = '1') THEN
               error_capture_code_blocked <= '1' ;
            END IF;
         END IF;
         IF (rst = '1') THEN
            error_capture_code_blocked <= '0';
         END IF;
      END IF;
   END PROCESS;

END ARCHITECTURE RTL;

----------------------------------------------------------------------------------------------
--
-- VHDL file generated by X-HDL - Revision 3.2.53  Aug. 1, 2005
-- Tue Aug  9 07:33:50 2005
--
--      Input file         : C:/Documents and Settings/BryantI/My Documents/tmp/can_top.v
--      Design name        : can_top
--      Author             :
--      Company            : Actel
--
--      Description        :
--
--
----------------------------------------------------------------------------------------------
--
--////////////////////////////////////////////////////////////////////
--//                                                              ////
--//  can_top.v                                                   ////
--//                                                              ////
--//                                                              ////
--//  This file is part of the CAN Protocol Controller            ////
--//  http://www.opencores.org/projects/can/                      ////
--//                                                              ////
--//                                                              ////
--//  Author(s):                                                  ////
--//       Igor Mohor                                             ////
--//       igorm@opencores.org                                    ////
--//                                                              ////
--//                                                              ////
--//  All additional information is available in the README.txt   ////
--//  file.                                                       ////
--//                                                              ////
--////////////////////////////////////////////////////////////////////
--//                                                              ////
--// Copyright (C) 2002, 2003, 2004 Authors                       ////
--//                                                              ////
--// This source file may be used and distributed without         ////
--// restriction provided that this copyright statement is not    ////
--// removed from the file and that any derivative work contains  ////
--// the original copyright notice and the associated disclaimer. ////
--//                                                              ////
--// This source file is free software; you can redistribute it   ////
--// and/or modify it under the terms of the GNU Lesser General   ////
--// Public License as published by the Free Software Foundation; ////
--// either version 2.1 of the License, or (at your option) any   ////
--// later version.                                               ////
--//                                                              ////
--// This source is distributed in the hope that it will be       ////
--// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
--// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
--// PURPOSE.  See the GNU Lesser General Public License for more ////
--// details.                                                     ////
--//                                                              ////
--// You should have received a copy of the GNU Lesser General    ////
--// Public License along with this source; if not, download it   ////
--// from http://www.opencores.org/lgpl.shtml                     ////
--//                                                              ////
--// The CAN protocol is developed by Robert Bosch GmbH and       ////
--// protected by patents. Anybody who wants to implement this    ////
--// CAN IP core on silicon has to obtain a CAN protocol license  ////
--// from Bosch.                                                  ////
--//                                                              ////
--////////////////////////////////////////////////////////////////////
--
-- CVS Revision History
--
-- $Log: can_top.v,v $
-- Revision 1.48  2004/10/25 11:44:47  igorm
-- Interrupt is always cleared for one clock after the irq register is read.
-- This fixes problems when CPU is using IRQs that are edge triggered.
--
-- Revision 1.47  2004/02/08 14:53:54  mohor
-- Header changed. Address latched to posedge. bus_off_on signal added.
--
-- Revision 1.46  2003/10/17 05:55:20  markom
-- mbist signals updated according to newest convention
--
-- Revision 1.45  2003/09/30 00:55:13  mohor
-- Error counters fixed to be compatible with Bosch VHDL reference model.
-- Small synchronization changes.
--
-- Revision 1.44  2003/09/25 18:55:49  mohor
-- Synchronization changed, error counters fixed.
--
-- Revision 1.43  2003/08/20 09:57:39  mohor
-- Tristate signal tx_o is separated to tx_o and tx_oen_o. Both signals need
-- to be joined together on higher level.
--
-- Revision 1.42  2003/07/16 15:11:28  mohor
-- Fixed according to the linter.
--
-- Revision 1.41  2003/07/10 15:32:27  mohor
-- Unused signal removed.
--
-- Revision 1.40  2003/07/10 01:59:04  tadejm
-- Synchronization fixed. In some strange cases it didn't work according to
-- the VHDL reference model.
--
-- Revision 1.39  2003/07/07 11:21:37  mohor
-- Little fixes (to fix warnings).
--
-- Revision 1.38  2003/07/03 09:32:20  mohor
-- Synchronization changed.
--
-- Revision 1.37  2003/06/27 20:56:15  simons
-- Virtual silicon ram instances added.
--
-- Revision 1.36  2003/06/17 14:30:30  mohor
-- "chip select" signal cs_can_i is used only when not using WISHBONE
-- interface.
--
-- Revision 1.35  2003/06/16 13:57:58  mohor
-- tx_point generated one clk earlier. rx_i registered. Data corrected when
-- using extended mode.
--
-- Revision 1.34  2003/06/13 15:02:24  mohor
-- Synchronization is also needed when transmitting a message.
--
-- Revision 1.33  2003/06/11 14:21:35  mohor
-- When switching to tx, sync stage is overjumped.
--
-- Revision 1.32  2003/06/09 11:32:36  mohor
-- Ports added for the CAN_BIST.
--
-- Revision 1.31  2003/03/26 11:19:46  mohor
-- CAN interrupt is active low.
--
-- Revision 1.30  2003/03/20 17:01:17  mohor
-- unix.
--
-- Revision 1.28  2003/03/14 19:36:48  mohor
-- can_cs signal used for generation of the cs.
--
-- Revision 1.27  2003/03/12 05:56:33  mohor
-- Bidirectional port_0_i changed to port_0_io.
-- input cs_can changed to cs_can_i.
--
-- Revision 1.26  2003/03/12 04:39:40  mohor
-- rd_i and wr_i are active high signals. If 8051 is connected, these two signals
-- need to be negated one level higher.
--
-- Revision 1.25  2003/03/12 04:17:36  mohor
-- 8051 interface added (besides WISHBONE interface). Selection is made in
-- can_defines.v file.
--
-- Revision 1.24  2003/03/10 17:24:40  mohor
-- wire declaration added.
--
-- Revision 1.23  2003/03/05 15:33:13  mohor
-- tx_o is now tristated signal. tx_oen and tx_o combined together.
--
-- Revision 1.22  2003/03/05 15:01:56  mohor
-- Top level signal names changed.
--
-- Revision 1.21  2003/03/01 22:53:33  mohor
-- Actel APA ram supported.
--
-- Revision 1.20  2003/02/19 15:09:02  mohor
-- Incomplete sensitivity list fixed.
--
-- Revision 1.19  2003/02/19 15:04:14  mohor
-- Typo fixed.
--
-- Revision 1.18  2003/02/19 14:44:03  mohor
-- CAN core finished. Host interface added. Registers finished.
-- Synchronization to the wishbone finished.
--
-- Revision 1.17  2003/02/18 00:10:15  mohor
-- Most of the registers added. Registers "arbitration lost capture", "error code
-- capture" + few more still need to be added.
--
-- Revision 1.16  2003/02/14 20:17:01  mohor
-- Several registers added. Not finished, yet.
--
-- Revision 1.15  2003/02/12 14:25:30  mohor
-- abort_tx added.
--
-- Revision 1.14  2003/02/11 00:56:06  mohor
-- Wishbone interface added.
--
-- Revision 1.13  2003/02/09 18:40:29  mohor
-- Overload fixed. Hard synchronization also enabled at the last bit of
-- interframe.
--
-- Revision 1.12  2003/02/09 02:24:33  mohor
-- Bosch license warning added. Error counters finished. Overload frames
-- still need to be fixed.
--
-- Revision 1.11  2003/02/04 14:34:52  mohor
-- *** empty log message ***
--
-- Revision 1.10  2003/01/31 01:13:38  mohor
-- backup.
--
-- Revision 1.9  2003/01/15 13:16:48  mohor
-- When a frame with "remote request" is received, no data is stored to
-- fifo, just the frame information (identifier, ...). Data length that
-- is stored is the received data length and not the actual data length
-- that is stored to fifo.
--
-- Revision 1.8  2003/01/14 17:25:09  mohor
-- Addresses corrected to decimal values (previously hex).
--
-- Revision 1.7  2003/01/10 17:51:34  mohor
-- Temporary version (backup).
--
-- Revision 1.6  2003/01/09 21:54:45  mohor
-- rx fifo added. Not 100 % verified, yet.
--
-- Revision 1.5  2003/01/08 02:10:56  mohor
-- Acceptance filter added.
--
-- Revision 1.4  2002/12/28 04:13:23  mohor
-- Backup version.
--
-- Revision 1.3  2002/12/27 00:12:52  mohor
-- Header changed, testbench improved to send a frame (crc still missing).
--
-- Revision 1.2  2002/12/26 16:00:34  mohor
-- Testbench define file added. Clock divider register added.
--
-- Revision 1.1.1.1  2002/12/20 16:39:21  mohor
-- Initial
--
--
--
-- synopsys translate_off
--`include "can_defines.v"
-- synopsys translate_on

LIBRARY ieee;
USE ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library grlib;
use grlib.stdlib.all;

ENTITY can_top_core_sync IS
   PORT (

      clk                        : IN std_logic;
      reset_n                    : IN std_logic;

      -- Config
      sjw                        : IN std_logic_vector(1 DOWNTO 0);
      bitrate                    : IN std_logic_vector(10 DOWNTO 0); --##
      tseg1                      : IN std_logic_vector(3 DOWNTO 0);
      tseg2                      : IN std_logic_vector(2 DOWNTO 0);
      auto_restart               : IN std_logic;
      sampling                   : IN std_logic;
      edge_mode                  : IN std_logic;

      -- Transmit buffer
      tx_data                    : IN  std_logic_vector(63 DOWNTO 0);
      tx_id                      : IN  std_logic_vector(28 DOWNTO 0);
      tx_dlc                     : IN  std_logic_vector(3  DOWNTO 0);
      tx_rtr                     : IN  std_logic;
      tx_ide                     : IN  std_logic;
      tx_msg_rdy                 : OUT std_logic;
      tx_request                 : IN  std_logic;

      -- start-stop control
      clr_stop                   : IN std_logic;
      set_stop                   : IN std_logic;

      -- start-stop status
      want_stop                  : OUT std_logic;
      grant_stop                 : OUT std_logic;

      -- Receive buffer
      rx_data                    : OUT std_logic_vector(63 DOWNTO 0);
      rx_id                      : OUT std_logic_vector(28 DOWNTO 0);
      rx_dlc                     : OUT std_logic_vector(3 DOWNTO 0);
      rx_rtr                     : OUT std_logic;
      rx_ide                     : OUT std_logic;
      rx_msg_rdy                 : OUT std_logic;

      -- Interrupt events
      crc_err                    : OUT std_logic;
      form_err                   : OUT std_logic;
      ack_err                    : OUT std_logic;
      stuff_err                  : OUT std_logic;
      bit_err                    : OUT std_logic;
      arb_loss                   : OUT std_logic;
      overload                   : OUT std_logic;

      -- Status and error counters
      error_state                : OUT std_logic_vector(1 DOWNTO 0);
      rx_err_gte96               : OUT std_logic;
      tx_err_gte96               : OUT std_logic;
      rx_err_cnt                 : OUT std_logic_vector(7 DOWNTO 0);
      tx_err_cnt                 : OUT std_logic_vector(8 DOWNTO 0);

      -- CAN frame reference
      rx_mode                    : OUT std_logic;
      tx_mode                    : OUT std_logic;
      field                      : OUT std_logic_vector(4 DOWNTO 0);
      bit_nr                     : OUT std_logic_vector(5 DOWNTO 0);
      stuff_ind                  : OUT std_logic;
      remote_ind                 : OUT std_logic;
      extended_ind               : OUT std_logic;

      -- CAN physical layer interface
      can_rx_bus                 : IN  std_logic;
      can_tx_bus                 : OUT std_logic;
      can_bus_ebl_n              : OUT std_logic);

END ENTITY can_top_core_sync;

ARCHITECTURE RTL OF can_top_core_sync IS

   COMPONENT can_bsp_core_sync
      PORT (
         clk                     : IN  std_logic;
         rst                     : IN  std_logic;
         restart                 : IN  std_logic;
         sample_point            : IN  std_logic;
         sampled_bit             : IN  std_logic;
         sampled_bit_q           : IN  std_logic;
         tx_point                : IN  std_logic;
         hard_sync               : IN  std_logic;
         reset_mode              : IN  std_logic;
         listen_only_mode        : IN  std_logic;
         self_test_mode          : IN  std_logic;
         tx_request              : IN  std_logic;
         abort_tx                : IN  std_logic;
         self_rx_request         : IN  std_logic;
         single_shot_transmission: IN  std_logic;
         tx_state                : OUT std_logic;
         tx_state_q              : OUT std_logic;
         overload_request        : IN  std_logic;
         overload_frame          : OUT std_logic;
         read_arbitration_lost_capture_reg: IN  std_logic;
         read_error_code_capture_reg: IN  std_logic;
         error_capture_code      : OUT std_logic_vector(7 DOWNTO 0);
         extended_mode           : IN  std_logic;
         rx_idle                 : OUT std_logic;
         transmitting            : OUT std_logic;
         transmitter             : OUT std_logic;
         go_rx_inter             : OUT std_logic;
         not_first_bit_of_inter  : OUT std_logic;
         rx_inter                : OUT std_logic;
         node_bus_off            : OUT std_logic;
         rx_err_cnt              : OUT std_logic_vector(8 DOWNTO 0);
         tx_err_cnt              : OUT std_logic_vector(8 DOWNTO 0);
         transmit_status         : OUT std_logic;
         receive_status          : OUT std_logic;
         tx_successful           : OUT std_logic;
         need_to_tx              : OUT std_logic;
         overrun                 : OUT std_logic;
         set_bus_error_irq       : OUT std_logic;
         set_arbitration_lost_irq: OUT std_logic;
         arbitration_lost_capture: OUT std_logic_vector(4 DOWNTO 0);
         node_error_passive      : OUT std_logic;
         node_error_active       : OUT std_logic;
         tx_data_0               : IN  std_logic_vector(7 DOWNTO 0);
         tx_data_1               : IN  std_logic_vector(7 DOWNTO 0);
         tx_data_2               : IN  std_logic_vector(7 DOWNTO 0);
         tx_data_3               : IN  std_logic_vector(7 DOWNTO 0);
         tx_data_4               : IN  std_logic_vector(7 DOWNTO 0);
         tx_data_5               : IN  std_logic_vector(7 DOWNTO 0);
         tx_data_6               : IN  std_logic_vector(7 DOWNTO 0);
         tx_data_7               : IN  std_logic_vector(7 DOWNTO 0);
         tx_data_8               : IN  std_logic_vector(7 DOWNTO 0);
         tx_data_9               : IN  std_logic_vector(7 DOWNTO 0);
         tx_data_10              : IN  std_logic_vector(7 DOWNTO 0);
         tx_data_11              : IN  std_logic_vector(7 DOWNTO 0);
         tx_data_12              : IN  std_logic_vector(7 DOWNTO 0);

         rcv_msg_data            : out std_logic_vector(63 downto 0);
         rcv_id                  : out std_logic_vector(28 downto 0);
         rcv_dlc                 : out std_logic_vector(3 downto 0);
         rcv_rtr                 : out std_logic;
         rcv_ide                 : out std_logic;
         rcv_msg_valid           : out std_logic;

         form_error              : out std_logic;
         crc_error               : out std_logic;
         ack_error               : out std_logic;
         stuff_error             : out std_logic;
         bit_error               : out std_logic;
         arb_loss                : out std_logic;

         tx                      : OUT std_logic;
         tx_next                 : OUT std_logic;
         go_overload_frame       : OUT std_logic;
         go_error_frame          : OUT std_logic;
         go_tx                   : OUT std_logic;
         send_ack                : OUT std_logic);
   END COMPONENT;

   COMPONENT can_btl_core_sync
      PORT (
         clk                     : IN  std_logic;
         rst                     : IN  std_logic;
         rx                      : IN  std_logic;
         tx                      : IN  std_logic;
         baud_r_presc            : IN  std_logic_vector(10 DOWNTO 0); --##
         sync_jump_width         : IN  std_logic_vector(1 DOWNTO 0);
         time_segment1           : IN  std_logic_vector(3 DOWNTO 0);
         time_segment2           : IN  std_logic_vector(2 DOWNTO 0);
         triple_sampling         : IN  std_logic;
         sample_point            : OUT std_logic;
         sampled_bit             : OUT std_logic;
         sampled_bit_q           : OUT std_logic;
         tx_point                : OUT std_logic;
         hard_sync               : OUT std_logic;
         rx_idle                 : IN  std_logic;
         rx_inter                : IN  std_logic;
         transmitting            : IN  std_logic;
         transmitter             : IN  std_logic;
         go_rx_inter             : IN  std_logic;
         tx_next                 : IN  std_logic;
         go_overload_frame       : IN  std_logic;
         go_error_frame          : IN  std_logic;
         go_tx                   : IN  std_logic;
         send_ack                : IN  std_logic;
         node_error_passive      : IN  std_logic);
   END COMPONENT;



   SIGNAL reset_mode               :  std_logic;
   SIGNAL listen_only_mode         :  std_logic;
   SIGNAL self_test_mode           :  std_logic;
   SIGNAL abort_tx                 :  std_logic;
   SIGNAL self_rx_request          :  std_logic;
   SIGNAL single_shot_transmission :  std_logic;

   SIGNAL tx_state                 :  std_logic;
   SIGNAL tx_state_q               :  std_logic;
   SIGNAL overload_request         :  std_logic;
   SIGNAL overload_frame           :  std_logic;

   SIGNAL error_capture_code       :  std_logic_vector(7 DOWNTO 0);

   -- Clock Divider register
   SIGNAL extended_mode            :  std_logic;

   -- Tx data registers. Holding identifier (basic mode), tx frame information (extended mode) and data
   SIGNAL tx_data_0                :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tx_data_1                :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tx_data_2                :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tx_data_3                :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tx_data_4                :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tx_data_5                :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tx_data_6                :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tx_data_7                :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tx_data_8                :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tx_data_9                :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tx_data_10               :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tx_data_11               :  std_logic_vector(7 DOWNTO 0);
   SIGNAL tx_data_12               :  std_logic_vector(7 DOWNTO 0);

   -- Output signals from can_btl_core_sync module
   SIGNAL sample_point             :  std_logic;
   SIGNAL sampled_bit              :  std_logic;
   SIGNAL sampled_bit_q            :  std_logic;
   SIGNAL tx_point                 :  std_logic;
   SIGNAL hard_sync                :  std_logic;
   -- output from can_bsp_core_sync module
   SIGNAL rx_idle                  :  std_logic;
   SIGNAL transmitting             :  std_logic;
   SIGNAL transmitter              :  std_logic;
   SIGNAL go_rx_inter              :  std_logic;
   SIGNAL not_first_bit_of_inter   :  std_logic;
   SIGNAL node_bus_off             :  std_logic;
   SIGNAL transmit_status          :  std_logic;
   SIGNAL receive_status           :  std_logic;
   SIGNAL tx_successful            :  std_logic;
   SIGNAL need_to_tx               :  std_logic;
   SIGNAL overrun                  :  std_logic;
   SIGNAL node_error_passive       :  std_logic;
   SIGNAL node_error_active        :  std_logic;
   SIGNAL tx_next                  :  std_logic;
   SIGNAL go_overload_frame        :  std_logic;
   SIGNAL go_error_frame           :  std_logic;
   SIGNAL go_tx                    :  std_logic;
   SIGNAL send_ack                 :  std_logic;
--   SIGNAL rst                      :  std_logic;


   SIGNAL rx_sync_tmp              :  std_logic;
   SIGNAL rx_sync                  :  std_logic;


   SIGNAL xhdl_148                 :  std_logic_vector(8 DOWNTO 0);
   SIGNAL xhdl_150                 :  std_logic_vector(8 DOWNTO 0);

   SIGNAL tx_o_xhdl3               :  std_logic;

   SIGNAL rx_inter                 :  std_logic;

   signal rst, restart : std_logic;
   signal ide, rtr : std_logic;
   signal tx_req, tx_request_q, tx_success : std_logic;

BEGIN

   rst <= not reset_n;

   -- outputs
   can_tx_bus     <= tx_o_xhdl3;
   can_bus_ebl_n  <= '1' when reset_n = '0' else '1';

   rx_err_cnt     <= xhdl_148(7 DOWNTO 0);
   tx_err_cnt     <= xhdl_150(8 DOWNTO 0);
   rx_err_gte96   <= '1' when unsigned(xhdl_148) >= 96 else '0';
   tx_err_gte96   <= '1' when unsigned(xhdl_150) >= 96 else '0';
   error_state(0) <= '0' when (node_error_active = '1') else '1';
   error_state(1) <= '0' when (node_bus_off = '0') else '1';

   tx_msg_rdy     <= tx_success;

   rx_rtr         <= rtr;
   rx_ide         <= ide;

   rx_mode        <= receive_status;
   tx_mode        <= tx_state or tx_success; --## transmit_status;

   remote_ind     <= rtr;
   extended_ind   <= ide;
   stuff_ind      <= '0';
   bit_nr         <= (others => '0');
   field          <= (others => '0');
   overload       <= overload_frame;

   want_stop      <= '0';
   grant_stop     <= '0';

   i_can_btl_core_sync : can_btl_core_sync
      PORT MAP (
         clk => clk,
         rst => rst,
         rx => rx_sync,
         tx => tx_o_xhdl3,
         baud_r_presc => bitrate, --##
         sync_jump_width => sjw,
         time_segment1 => tseg1,
         time_segment2 => tseg2,
         triple_sampling => sampling,
         sample_point => sample_point,
         sampled_bit => sampled_bit,
         sampled_bit_q => sampled_bit_q,
         tx_point => tx_point,
         hard_sync => hard_sync,
         rx_idle => rx_idle,
         rx_inter => rx_inter,
         transmitting => transmitting,
         transmitter => transmitter,
         go_rx_inter => go_rx_inter,
         tx_next => tx_next,
         go_overload_frame => go_overload_frame,
         go_error_frame => go_error_frame,
         go_tx => go_tx,
         send_ack => send_ack,
         node_error_passive => node_error_passive);


   -- TX format conversion
   tx_data_0  <= tx_ide & tx_rtr & "00" & tx_dlc;
   tx_data_1  <= tx_id(28 downto 21);
   tx_data_2  <= tx_id(20 downto 18) & "00000" when tx_ide = '0' else tx_id(20 downto 13);
   tx_data_3  <= tx_data(63 downto 56)         when tx_ide = '0' else tx_id(12 downto 5);
   tx_data_4  <= tx_data(55 downto 48)         when tx_ide = '0' else tx_id(4 downto 0) & "000";
   tx_data_5  <= tx_data(47 downto 40)         when tx_ide = '0' else tx_data(63 downto 56);
   tx_data_6  <= tx_data(39 downto 32)         when tx_ide = '0' else tx_data(55 downto 48);
   tx_data_7  <= tx_data(31 downto 24)         when tx_ide = '0' else tx_data(47 downto 40);
   tx_data_8  <= tx_data(23 downto 16)         when tx_ide = '0' else tx_data(39 downto 32);
   tx_data_9  <= tx_data(15 downto 8)          when tx_ide = '0' else tx_data(31 downto 24);
   tx_data_10 <= tx_data(7 downto 0)           when tx_ide = '0' else tx_data(23 downto 16);
   tx_data_11 <= tx_data(15 downto 8);
   tx_data_12 <= tx_data(7 downto 0);


   reset_mode <= '1' when rst = '1' else '0';
   listen_only_mode <= '0';
   self_test_mode <= '0';
   extended_mode <= '1';
   overload_request <= '0';
   abort_tx <= '0';
   self_rx_request <= '0';
   single_shot_transmission <= '1'; --##

   restart <= '1' when (auto_restart = '0' and clr_stop = '1') else '0';

   -- generate pulse
   process(clk,rst)
   begin
   if rst='1' then
      tx_req <= '0';
   elsif Rising_Edge(clk) then
      if tx_request='1' and transmit_status='0' then
         tx_req <= '1';
      elsif transmit_status='1' then
         tx_req <= '0';
      end if;
   end if;
   end process;


   i_can_bsp_core_sync : can_bsp_core_sync
      PORT MAP (
         clk => clk,
         rst => rst,
         restart => restart,
         sample_point => sample_point,
         sampled_bit => sampled_bit,
         sampled_bit_q => sampled_bit_q,
         tx_point => tx_point,
         hard_sync => hard_sync,
         reset_mode => reset_mode,
         listen_only_mode => listen_only_mode,
         self_test_mode => self_test_mode,
         tx_request => tx_req, --## tx_request, --##
         abort_tx => abort_tx,
         self_rx_request => self_rx_request,
         single_shot_transmission => single_shot_transmission,
         tx_state => tx_state,
         tx_state_q => tx_state_q,
         overload_request => overload_request,
         overload_frame => overload_frame,
         read_arbitration_lost_capture_reg => '0',
         read_error_code_capture_reg => '0',
         error_capture_code => open,
         extended_mode => extended_mode,
         rx_idle => rx_idle,
         transmitting => transmitting,
         transmitter => transmitter,
         go_rx_inter => go_rx_inter,
         not_first_bit_of_inter => not_first_bit_of_inter,
         rx_inter => rx_inter,
         node_bus_off => node_bus_off,
         rx_err_cnt => xhdl_148,
         tx_err_cnt => xhdl_150,
         transmit_status => transmit_status,
         receive_status => receive_status,
         tx_successful => tx_successful,
         need_to_tx => need_to_tx,
         overrun => overrun,

         set_bus_error_irq => open,
         set_arbitration_lost_irq => open,
         arbitration_lost_capture => open,
         node_error_passive => node_error_passive,
         node_error_active => node_error_active,

         tx_data_0 => tx_data_0,
         tx_data_1 => tx_data_1,
         tx_data_2 => tx_data_2,
         tx_data_3 => tx_data_3,
         tx_data_4 => tx_data_4,
         tx_data_5 => tx_data_5,
         tx_data_6 => tx_data_6,
         tx_data_7 => tx_data_7,
         tx_data_8 => tx_data_8,
         tx_data_9 => tx_data_9,
         tx_data_10 => tx_data_10,
         tx_data_11 => tx_data_11,
         tx_data_12 => tx_data_12,

         rcv_msg_data  => rx_data,
         rcv_id        => rx_id,
         rcv_dlc       => rx_dlc,
         rcv_rtr       => rtr,
         rcv_ide       => ide,
         rcv_msg_valid => rx_msg_rdy,

         form_error  => form_err,
         crc_error   => crc_err,
         ack_error   => ack_err,
         stuff_error => stuff_err,
         bit_error   => bit_err,
         arb_loss    => arb_loss,

         tx => tx_o_xhdl3,
         tx_next => tx_next,
         go_overload_frame => go_overload_frame,
         go_error_frame => go_error_frame,
         go_tx => go_tx,
         send_ack => send_ack);

   PROCESS (clk, rst)
   BEGIN
      IF (clk'EVENT AND clk = '1') THEN
        IF (rst = '1') THEN
--           rx_sync_tmp <= '1';
           rx_sync      <= '1';
           tx_request_q <= '0';
           tx_success   <= '0';
        ELSE
--           rx_sync_tmp <= can_rx_bus;
--           rx_sync <= rx_sync_tmp ;
           rx_sync      <= can_rx_bus;
           tx_request_q <= tx_request;
           tx_success   <= tx_successful;
        END IF;
      END IF;
   END PROCESS;

END ARCHITECTURE RTL;
